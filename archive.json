{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-03-25T01:25:15.961553+00:00",
  "repo": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 7,
      "id": "I_kwDOJfxSy85mfrPf",
      "title": "Sizes of key shares are off-by-one",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/7",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I get off-by-one for the sizes of key shares.\r\n\r\nThe given size of client key share seems to be size of kyber public key\r\nplus 64 bytes, and given size of server key share seems to be the size\r\nof kyber ciphertext plus 64 bytes.\r\n\r\nHowever, the difference is stated to be UncompressedPointRepresentation\r\nfor P256 from TLS 1.3. AFACIT, that is 65 bytes (1 legacy_form byte,\r\n32 bytes for x, 32 bytes for y).\r\n\r\nSo I get that the client share should be 1249 bytes (instead of 1248\r\nbytes) and the server key share should be 1153 bytes (instead of 1152\r\nbytes).\r\n\r\nObviously something is wrong somewhere, but where?\r\n",
      "createdAt": "2023-05-22T12:21:00Z",
      "updatedAt": "2023-05-31T09:32:58Z",
      "closedAt": "2023-05-31T09:32:58Z",
      "comments": [
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Kris,\r\nIndeed, I did a capture in TLS 1.3 and the `secp256r1` `keyshare` is 65bytes. So the stated lengths should be 1249 and 1153. That is what goes in the TLS keyshare on the wire of course. ",
          "createdAt": "2023-05-22T15:37:26Z",
          "updatedAt": "2023-05-22T15:38:40Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@csosto-pk Thanks for checking that. Indeed, it seems I've missed ``legacy_form`` bytes. I'll fix that.",
          "createdAt": "2023-05-22T18:19:39Z",
          "updatedAt": "2023-05-22T18:19:39Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOJfxSy851_m9-",
      "title": "Change name from Kyber to MLKEM",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/11",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T16:54:08Z",
      "updatedAt": "2024-08-14T14:18:06Z",
      "closedAt": "2024-08-14T14:18:06Z",
      "comments": [
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kriskwiatkowski , I don't think we should any changes to [draft-kwiatkowski-tls-ecdhe-kyber](https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-kyber). This draft was to only get a temporary identifier to negotiate in TLS 1.3. This draft serves as the necessary \"stable reference\" to get the identifier through the \"Expert Review process\". It should not be considered as a draft that will keep getting updated and ratified.\r\n\r\n[draft-ietf-tls-hybrid-design](https://datatracker.ietf.org/doc/draft-ietf-tls-hybrid-design/) was agreed in the TLS WG to be the standards draft which will give us the identifiers for the final ML-KEM spec like `secp392-mlkem768` or `secp392-mlkem1024` or `x25519-mlkem768`. ",
          "createdAt": "2023-11-07T03:14:20Z",
          "updatedAt": "2023-11-07T03:19:02Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "The temporary codepoint is assigned to version -01 of this draft. That's done now.\r\n\r\nIf we are going to get a codepoint for final version of MLKEM thru draft-ietf-tls-hybrid-design, than that's fine. Otherwise I would like to try to use this draft to get it.",
          "createdAt": "2023-11-07T06:02:30Z",
          "updatedAt": "2023-11-07T06:03:25Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "The  draft-ietf-tls-hybrid-design will keep only secp256+mlkem768 and x25519+mlkem768. I think now it makes sense to update the Kyber -> MLKEM\r\n\r\nhttps://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-09.html#name-defined-hybrid-groups\r\n\r\n@csosto-pk good for you?",
          "createdAt": "2024-03-18T23:50:45Z",
          "updatedAt": "2024-03-18T23:51:26Z"
        },
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "draft-kwiatkowski-tls-ecdhe-kyber currently only has SecP256r1Kyber768Draft00.\r\n\r\nSince that one with ml-kem, our course, will make it to [draft-ietf-tls-hybrid-design-09.html#name-defined-hybrid-groups](https://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-09.html#name-defined-hybrid-groups), what new OIDs were you thinking to include draft-kwiatkowski-tls-ecdhe-kyber?",
          "createdAt": "2024-03-19T02:01:08Z",
          "updatedAt": "2024-03-19T02:02:09Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "As I understood today (I'm at IETF), the [draft-ietf-tls-hybrid-design-09.html](https://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-09.html#name-defined-hybrid-groups) would prefer to refer to MLKEM rather then Kyber. For this we need to update this draft and refer to FIPS-203 rather than draft-cfrg-schwabe-kyber-02. Those are two different schemes, hence new codepoint is needed.",
          "createdAt": "2024-03-19T03:10:41Z",
          "updatedAt": "2024-03-19T03:10:41Z"
        },
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we do. The codepoint we got already in https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8 which points to https://datatracker.ietf.org/doc/draft-kwiatkowski-tls-ecdhe-kyber/01/ for SecP256r1Kyber768Draft00 is based on Kyber768 Round 3 (draft-cfrg-schwabe-kyber-02). It is assigned and early adopters deployed it.\r\n\r\nNow draft-ietf-tls-hybrid-design will get two \"permanent codepoints\" for x25519+MLKEM768 and P256+MLKEM768. So, we will have the \"final codepoints\" from that. Why would we update draft-kwiatkowski-tls-ecdhe-kyber to get codepoints for P256+MLKEM768 since draft-ietf-tls-hybrid-design will do it anyway?\r\n \r\nAm I misunderstanding you?",
          "createdAt": "2024-03-19T03:24:00Z",
          "updatedAt": "2024-03-19T03:24:00Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "I think it is expected that draft-kwiatkowski-tls-ecdhe-kyber will be updated and used to get \"permanent codepoint\" for MLKEM (same for the X25519). \r\nThen [draft-ietf-tls-hybrid-design](https://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-09.html#name-defined-hybrid-groups) includes updated version with MLKEM codepoint.",
          "createdAt": "2024-03-19T03:27:16Z",
          "updatedAt": "2024-03-19T03:28:24Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Sorry, I'm assuming Kyber and final version of MLKEM won't be compatible. No change is required if they are compatible (obviously).",
          "createdAt": "2024-03-19T07:13:51Z",
          "updatedAt": "2024-03-19T07:13:51Z"
        },
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was under the impression that from the beginning [draft-ietf-tls-hybrid-design](https://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-09.html#name-defined-hybrid-groups) was going to get the final `x25519+MLKEM768` and `P256+MLKEM768` OIDs for TLS. I am pretty sure that was the consensus on the list too, but maybe I am misremembering. \r\n\r\nIf that is not the case, then indeed another draft needs to get them. \r\n\r\nAre you sure it was said in the meeting that draft-ietf-tls-hybrid-design will not get the final OIDs? I think I will try to go back to the recording too.",
          "createdAt": "2024-03-19T13:32:28Z",
          "updatedAt": "2024-03-19T13:32:28Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOJfxSy851_nIi",
      "title": "Add secp384mlkem1024 combination",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/12",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T16:54:32Z",
      "updatedAt": "2023-11-07T05:45:28Z",
      "closedAt": "2023-11-07T05:45:28Z",
      "comments": [
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kriskwiatkowski , I don't think we need to add secp384mlkem768 to [draft-kwiatkowski-tls-ecdhe-kyber](https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-kyber). This draft was to only get a temporary identifier to negotiate in TLS 1.3 until we have the final ML-KEM. I don't think we need another temporary one for ML-KEM-768. We can wait to get secp384mlkem768 from [draft-ietf-tls-hybrid-design](https://datatracker.ietf.org/doc/draft-ietf-tls-hybrid-design/).",
          "createdAt": "2023-11-07T03:08:07Z",
          "updatedAt": "2023-11-07T03:08:40Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "ok",
          "createdAt": "2023-11-07T05:45:28Z",
          "updatedAt": "2023-11-07T05:45:28Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOJfxSy86Sqys4",
      "title": "Other combinations",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/13",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As MLKEM is out (soon), the good question now is - do we want to include codepoints for more combinations than P256-MLKEM768?\r\n\r\nI think P256-MLKEM768 should stay, but I don't have a clear opinion about use cases for other combinations. ",
      "createdAt": "2024-08-12T11:05:21Z",
      "updatedAt": "2024-10-16T17:40:56Z",
      "closedAt": "2024-10-16T17:40:56Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "Support for secp384+MLKEM...1024? I think? @tomato42 \r\n\r\nhttps://mailarchive.ietf.org/arch/msg/tls/YcjHZ6-dWL54lBQQavAUoyxf4sI/",
          "createdAt": "2024-10-16T17:31:01Z",
          "updatedAt": "2024-10-16T17:31:14Z"
        },
        {
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "body": "secp384r1MLKEM1024 is in already:\r\nhttps://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/blob/0eee72f28caf4a8c06bc9d661c7e39bf0271a424/draft-kwiatkowski-tls-ecdhe-mlkem.md?plain=1#L81",
          "createdAt": "2024-10-16T17:35:55Z",
          "updatedAt": "2024-10-16T17:35:55Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Yes, I think that is the only one we want to add. Should be done very soon.\r\nLet's close that issue.",
          "createdAt": "2024-10-16T17:40:56Z",
          "updatedAt": "2024-10-16T17:40:56Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOJfxSy86S_HQU",
      "title": "FIPS-203 reference",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/14",
      "state": "CLOSED",
      "author": "csosto-pk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We need to replace I-D.cfrg-schwabe-kyber with the FIPS-203 doc reference\r\n\r\n```\r\n        <reference anchor=\"FIPS203\" target=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf\">\r\n          <front>\r\n            <title>Module-Lattice-Based Key-Encapsulation Mechanism Standard</title>\r\n            <author>\r\n              <organization>National Institute of Standards and Technology (NIST)</organization>\r\n            </author>\r\n            <date year=\"2024\" month=\"August\" day=\"13\"/>\r\n          </front>\r\n          <seriesInfo name=\"NIST\" value=\"Federal Information Processing Standards\"/>\r\n        </reference>\r\n```",
      "createdAt": "2024-08-14T14:29:46Z",
      "updatedAt": "2024-08-14T15:08:08Z",
      "closedAt": "2024-08-14T15:08:08Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOJfxSy86S_Mzz",
      "title": "Double check if size of public key and ciphertext are according to FIPS-203",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/16",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-14T14:37:06Z",
      "updatedAt": "2024-08-14T15:09:07Z",
      "closedAt": "2024-08-14T15:09:07Z",
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Seems sizes in the this IETF draft are same as in the Table 2 of FIPS-203 (for ML-KEM-768)",
          "createdAt": "2024-08-14T15:04:21Z",
          "updatedAt": "2024-08-14T15:04:21Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJfxSy86S_NSd",
      "title": "Build doesn't work",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/17",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "For some reason, the build is broken. Investigate",
      "createdAt": "2024-08-14T14:37:44Z",
      "updatedAt": "2024-10-16T17:39:29Z",
      "closedAt": "2024-10-16T17:39:29Z",
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "Working now?",
          "createdAt": "2024-10-16T17:29:42Z",
          "updatedAt": "2024-10-16T17:29:42Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Yes :)\r\nSweet, thanks",
          "createdAt": "2024-10-16T17:39:29Z",
          "updatedAt": "2024-10-16T17:39:29Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOJfxSy86TOw_i",
      "title": "Public key validation",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/19",
      "state": "CLOSED",
      "author": "bwesterb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Perhaps good to spend a few words on what to do if the public key doesn't pass the new public key validation check. That'd be similar to sending a key share of the wrong size, and the appropriate thing to do would be to send a bad_parameter alert.",
      "createdAt": "2024-08-16T11:53:02Z",
      "updatedAt": "2024-08-26T01:28:30Z",
      "closedAt": "2024-08-26T01:28:30Z",
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Good point! Will do",
          "createdAt": "2024-08-18T15:22:31Z",
          "updatedAt": "2024-08-18T15:22:31Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Draft now contains following text:\r\n\r\n```\r\nFor both groups, the server MUST perform the encapsulation key check\r\ndescribed in Section 7.3 of {{FIPS203}} on the client's encapsulation\r\nkey, and abort with an illegal_parameter alert if it fails.\r\n```",
          "createdAt": "2024-08-26T01:28:26Z",
          "updatedAt": "2024-08-26T01:28:26Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOJfxSy86r0Dtv",
      "title": "Citations for P-256",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/29",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The document reads:\n\n   The second one uses secp256r1 (NIST P-256) [ECDSA] [DSS].  The goal\n   of this group is to support a use case that requires both shared\n   secrets to be generated by FIPS-approved mechanisms.\n\nThis is an odd set of citations for ECDH with P-256. Perhaps you instead\nwant: {{!KEYAGREEMENT=DOI.10.6028/NIST.SP.800-56Ar3}}, which is what\n8446-bis uses",
      "createdAt": "2025-02-26T19:03:52Z",
      "updatedAt": "2025-03-04T12:27:11Z",
      "closedAt": "2025-03-04T12:27:10Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOJfxSy86r05GI",
      "title": "Unclear what's the shared secret check in Section 5.7.1.2 of SP56A",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/30",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "3.1.3 says:\n\n> For all groups, both client and server MUST calculate the ECDH part of the shared secret as described in [Section 7.4.2](https://rfc-editor.org/rfc/rfc8446#section-7.4.2) of [[RFC8446](https://www.ietf.org/archive/id/draft-kwiatkowski-tls-ecdhe-mlkem-03.html#RFC8446)], including the shared secret check as described in Section 5.7.1.2 of [[SP56A](https://www.ietf.org/archive/id/draft-kwiatkowski-tls-ecdhe-mlkem-03.html#SP56A)] or the all-zero shared secret check (depending on the curve), and abort the connection with an illegal_parameter alert if it fails.\n\nLooking at SP561, I'm guessing this is referring to this bit?\n\n> If P = \u00d8, destroy all intermediate values used in the attempted computation of P, then output an error indicator, and exit this process without further processing.\n\nCalling it the \"shared secret\" check is slightly odd because P isn't the shared secret Z. It's something you use to compute it. (Also if you somehow forgot this check, you would be unable to compute Z in the first place. The point at infinity has no x-coordinate.)\n\nMore importantly, this case is actually impossible. All the applicable curves here are prime order (the SP56A citation is not talking about X25519), so this will only happen if the peer key was also the point at infinity. But the spec already says:\n\n> For all groups, both client and server MUST process the ECDH part as described in [Section 4.2.8.2](https://rfc-editor.org/rfc/rfc8446#section-4.2.8.2) of [[RFC8446](https://www.ietf.org/archive/id/draft-kwiatkowski-tls-ecdhe-mlkem-03.html#RFC8446)], including all validity checks, and abort with an illegal_parameter alert if it fails.\n\nThat text already precludes the point at infinity.\n\nWe also don't _need_ to reiterate things for ECDH that are already required in the specification for ECDH. It can be useful to reiterate things to emphasize them, but since this is actually impossible, it doesn't really need to be emphasized. (The X25519 check is different because that's optional in the base X25519 specification.)\n\nThus we should delete that confusing clause and simply replace it with:\n\n> For all groups, both client and server MUST calculate the ECDH part of the shared secret as described in [Section 7.4.2](https://rfc-editor.org/rfc/rfc8446#section-7.4.2) of [[RFC8446](https://www.ietf.org/archive/id/draft-kwiatkowski-tls-ecdhe-mlkem-03.html#RFC8446)], including the all-zero shared secret check for X25519, and abort the connection with an illegal_parameter alert if it fails.\n\n",
      "createdAt": "2025-02-26T20:43:37Z",
      "updatedAt": "2025-03-04T06:57:44Z",
      "closedAt": "2025-03-04T06:57:44Z",
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "I agree, that slipped thru my attention. But, indeed for curves with coffactor 1 this situation is impossible. I'm actually looking now at my old code and have pretty much the same comment as your comment above.",
          "createdAt": "2025-02-26T21:15:50Z",
          "updatedAt": "2025-02-26T21:15:50Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@tomato42 Ok by you?",
          "createdAt": "2025-02-26T21:50:54Z",
          "updatedAt": "2025-02-26T21:50:54Z"
        },
        {
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "body": "true, **P** is not the shared secret, but the implementation should still check if it isn't the point at infinity, it's a trivial check and may be _necessary_ for later standards that use different curves and this RFC as template...",
          "createdAt": "2025-02-28T12:57:34Z",
          "updatedAt": "2025-02-28T12:57:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tomato42 Looks like your responses on the PR and the issue are different, so I'll respond to those on each separately...\n\nCan you give an example of a different curve that where this would be necessary? (I believe the only curves in the TLS supported group registry with cofactors are X25519 and X448, where this would not be applicable anyway. Although I did not check the ones added in RFC 9189. Those aren't readily available in OpenSSL's giant table.)\n\nPeople mostly do not use curves with cofactors. Of the prime-field curves (as opposed to the binary field ones, which ~no one uses) in OpenSSL, the only ones with cofactors are secp112r2 and secp128r2. Is the concern that we might introduce one of them to TLS and hybridize with PQC?\n\nCofactors also actually complicate far more than this check. Now you have to worry about whether your ECDH algorithm is specified to clear the cofactor and whatnot. (I believe this is often called \"cofactor ECDH\".) So it's already the case that this draft would not be a suitable template.\n\nSure, almost all implementations would want to check. It is natural to implement ECDH by calling your generic EC point x-coordinate extraction function, and that would need to account for the point at infinity. As noted in https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/31#issuecomment-2690972391, the check is *already* covered by citation, because those specifications are also structured like that. But since it is _impossible_, not doing the check and doing it are equally conformant. So we should follow RFC 8446's precedent and observe that this check does not rise to the level of needing reiterating up the stack. We should retain our limited implementor attention budget on something that actually matters.",
          "createdAt": "2025-02-28T15:56:42Z",
          "updatedAt": "2025-02-28T15:56:42Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOJfxSy86tLGa0",
      "title": "Forbid reuse of private key",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/issues/34",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See e.g., this for a explanation why reuse of ephemeral keys are dangerous\nhttps://emanjon.github.io/NIST-comments/2025%20-%20SP%20800-227.pdf\nhttps://mailarchive.ietf.org/arch/msg/tls/rBbld01LhQ1EHa4FxCv8FbmYlDg/\nAccoding to draft-ietf-tls-hybrid-design this was also discussed raised by Bernstein and Lange. \n\"Daniel J. Bernstein and Tanja Lange commented on the risks of reuse of ephemeral public keys.\" \n\nThe following text has been suggested to draft-kwiatkowski-tls-ecdhe-mlkem and draft-ietf-tls-hybrid-design\n\n\"For all groups, both the client and server must not reuse the ECDH or the PQKEM portion of the key share across different connections. Reusing ephemeral keys ties key material from different connections together, which should remain unrelated. This vulnerability, combined with key reuse, could enable an attacker to recover the shared secret from another connection. Additionally, reusing keys raises significant privacy concerns, as it allows passive observers to correlate different connections.\"\n\nSee further discussion here:\nhttps://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/25\nhttps://github.com/dstebila/draft-ietf-tls-hybrid-design/issues/41\nhttps://github.com/dstebila/draft-ietf-tls-hybrid-design/pull/39\nhttps://github.com/dstebila/draft-ietf-tls-hybrid-design/pull/40\n\nNote that as draft-ietf-tls-hybrid-design is an informal draft informally referenced by, I do not think it is enough with a security consideration in draft-ietf-tls-hybrid-design. I would like normative language in draft-kwiatkowski-tls-ecdhe-mlkem regarding X25519MLKEM768.\n\n\n\n",
      "createdAt": "2025-03-09T11:25:17Z",
      "updatedAt": "2025-03-09T22:23:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "For the PQ portion, the server is responsible for encapsulation. The only potential mistake the server could make is reusing entropy when generating the value 'm' (refer to Algorithm 20 in FIPS-203), which would be a critical implementation flaw.\n\nHowever, even if this were to happen, the server derives the ciphertext using a hash of the ephemeral public key 'ek,' which is itself ephemeral.\n\nUltimately, regarding MLKEM, I'm unsure how to interpret that statement from the server's perspective. FIPS-203 already specifies that the value 'm' must not be reused, so this requirement is inherently covered by the standard.",
          "createdAt": "2025-03-09T22:20:23Z",
          "updatedAt": "2025-03-09T22:23:30Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOJfxSy85QTJYY",
      "title": "Updated IANA section",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/1",
      "state": "MERGED",
      "author": "csosto-pk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reused OQS OpenSSL identifiers and added clarity and comments in the IANA fields.",
      "createdAt": "2023-05-11T14:29:15Z",
      "updatedAt": "2023-05-12T21:06:06Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "f6e0784328df6e4442c256a92c66314b61c7073a",
      "headRepository": "csosto-pk/draft-kwiatkowski-tls-ecdhe-kyber",
      "headRefName": "patch-2",
      "headRefOid": "f3472a2bcf09cbea86f7b9e7c46cda5bcb968ce9",
      "closedAt": "2023-05-12T21:06:06Z",
      "mergedAt": "2023-05-12T21:06:06Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "04f2437b3a6b1fabafeb09b93950798441aee7b5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOJfxSy85QTJtK",
      "title": "Added secp521r1_kyber1024",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/2",
      "state": "CLOSED",
      "author": "csosto-pk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added secp521r1_kyber1024. \r\n\r\nBut we may not need secp521r1_kyber1024 in there if this is just a temporary code point. I don't see a new for it right now. Maybe we should just push for just a final codepoint after Kyber is ratified, not now. ",
      "createdAt": "2023-05-11T14:30:01Z",
      "updatedAt": "2023-05-12T20:12:48Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "f6e0784328df6e4442c256a92c66314b61c7073a",
      "headRepository": "csosto-pk/draft-kwiatkowski-tls-ecdhe-kyber",
      "headRefName": "patch-1",
      "headRefOid": "ee1f0cb0c663c00a0a2fef98f9cf5469ff0735ae",
      "closedAt": "2023-05-12T20:12:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing because we will only keep one new group.",
          "createdAt": "2023-05-12T20:12:47Z",
          "updatedAt": "2023-05-12T20:12:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDOJfxSy85QTNvf",
      "title": "Clarification about codepoints",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/3",
      "state": "MERGED",
      "author": "csosto-pk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarification that these codepoints are point-in-time, not the final ones for Kyber",
      "createdAt": "2023-05-11T14:39:25Z",
      "updatedAt": "2023-05-12T08:15:19Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "f6e0784328df6e4442c256a92c66314b61c7073a",
      "headRepository": "csosto-pk/draft-kwiatkowski-tls-ecdhe-kyber",
      "headRefName": "patch-3",
      "headRefOid": "423ab39cc45e1b156c69d48c522f9fcca7b13c16",
      "closedAt": "2023-05-12T08:15:18Z",
      "mergedAt": "2023-05-12T08:15:18Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "9e7ac6be2946b81ff5786cb25f011ba315032299"
      },
      "comments": [
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Need to add reference about the Round 3 Kyber, which is {{kyber}}\r\n\r\nDone.",
          "createdAt": "2023-05-11T14:49:24Z",
          "updatedAt": "2023-05-11T14:49:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy85UzhRB",
          "commit": {
            "abbreviatedOid": "d462e8d"
          },
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Need to add reference about the Round 3 Kyber, which is {{kyber}}",
          "createdAt": "2023-05-11T14:47:09Z",
          "updatedAt": "2023-05-11T14:47:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOJfxSy85Qai1T",
      "title": "Adding details about the exchanged data and keeping only one group",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/4",
      "state": "MERGED",
      "author": "csosto-pk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Details about encoding representations and sizes.",
      "createdAt": "2023-05-12T19:57:19Z",
      "updatedAt": "2023-05-17T09:48:29Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "9e7ac6be2946b81ff5786cb25f011ba315032299",
      "headRepository": "csosto-pk/draft-kwiatkowski-tls-ecdhe-kyber",
      "headRefName": "patch-4",
      "headRefOid": "a34f5be7cb0d2805bb48ff75cb742e1bc87f46b9",
      "closedAt": "2023-05-17T09:48:29Z",
      "mergedAt": "2023-05-17T09:48:28Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "38803521c89c800d56201ce2a6d3607e85e5a059"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOJfxSy85Qalxy",
      "title": "Added mention to FIPS",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/5",
      "state": "MERGED",
      "author": "csosto-pk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "And why this mechanism is FIPS approved",
      "createdAt": "2023-05-12T20:09:34Z",
      "updatedAt": "2023-05-17T07:49:28Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "9e7ac6be2946b81ff5786cb25f011ba315032299",
      "headRepository": "csosto-pk/draft-kwiatkowski-tls-ecdhe-kyber",
      "headRefName": "patch-5",
      "headRefOid": "a2928f1fa2e36a0f106388c14c74b85627a95e64",
      "closedAt": "2023-05-17T07:49:28Z",
      "mergedAt": "2023-05-17T07:49:28Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "02ee5d178db5818193cc0eed2ddddca1b1d31900"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOJfxSy85QaoZr",
      "title": "Changing title to be more intuitive",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/6",
      "state": "CLOSED",
      "author": "csosto-pk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-12T20:19:03Z",
      "updatedAt": "2023-05-18T07:29:08Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "9e7ac6be2946b81ff5786cb25f011ba315032299",
      "headRepository": "csosto-pk/draft-kwiatkowski-tls-ecdhe-kyber",
      "headRefName": "patch-6",
      "headRefOid": "223559070bcac8e1c89d8f5c728fa1ba2d7c9a88",
      "closedAt": "2023-05-18T07:29:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOJfxSy85Rw_AO",
      "title": "Sizes of key shares are off-by-one",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/8",
      "state": "MERGED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #7 ",
      "createdAt": "2023-05-31T09:32:01Z",
      "updatedAt": "2023-05-31T09:33:00Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "c2ac956efc69e00073511d2e326c40eefad09f4a",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/fix_1",
      "headRefOid": "1fba3163067cbb99ed40cae0792eee0050eaf031",
      "closedAt": "2023-05-31T09:32:57Z",
      "mergedAt": "2023-05-31T09:32:57Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "80cb46940f50b74b480904e0d15f447d1b3aafbc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOJfxSy85YdujP",
      "title": "Fix GitHub link, fix registry name, fix typo, add decimal value",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/9",
      "state": "MERGED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi! While going through the IANA registry I ran into this document.\r\n\r\nThe GitHub `venue` code is expanded here, as you can see it already prepends `https://github.com/`, so we can remove that:\r\nhttps://github.com/cabo/kramdown-rfc/blob/930935b2c42f5d453ed29baa474502bb3a58d39a/data/kramdown-rfc2629.erb#L126-L129",
      "createdAt": "2023-08-22T07:48:56Z",
      "updatedAt": "2023-09-26T11:34:55Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "bb9ff12c10919911a659d1d2b85ad9cf2a1635af",
      "headRepository": "Lekensteyn/draft-kwiatkowski-tls-ecdhe-kyber",
      "headRefName": "minor-fixes",
      "headRefOid": "27e393766ba6d3f2795e5b6cc6736b9ebc12e149",
      "closedAt": "2023-09-26T11:34:55Z",
      "mergedAt": "2023-09-26T11:34:55Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "ced5ed70bd9e2bb554ea73e1c5a2727fa225e94e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOJfxSy85etn-9",
      "title": "Kyber -> ML-KEM",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/10",
      "state": "MERGED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* Swapped all mentiones of \"Kyber\" to \"ML-KEM\"\r\n* Changed document name to draft-kwiatkowski-tls-ecdhe-mlkem\r\n* Updated the code point - just incremented a value (we can't use same as for SecP256r1Kyber768Draft00)\r\n\r\nThe build is not working well, it seems unrelated to this change. I'll fix it in a separate MR.\r\n\r\nCloses #11",
      "createdAt": "2023-11-06T16:51:09Z",
      "updatedAt": "2024-08-14T14:32:12Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "ced5ed70bd9e2bb554ea73e1c5a2727fa225e94e",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/mlkem",
      "headRefOid": "13820a8ed3cc5920bf22942663116ce8ea9d6df9",
      "closedAt": "2024-08-14T14:18:05Z",
      "mergedAt": "2024-08-14T14:18:05Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "097955264cfeaaa5a6ce0a854d9e11cd26752062"
      },
      "comments": [
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kriskwiatkowski I suggest to not submit the new version of the draft which include ML-KEM to the IETF for the reason explained in https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-kyber/issues/11#issuecomment-1797476565 .",
          "createdAt": "2023-11-07T03:15:38Z",
          "updatedAt": "2023-11-07T03:15:38Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Thanks @csosto-pk, it wasn't clear to me if identifires will be provided in [draft-ietf-tls-hybrid-design](https://datatracker.ietf.org/doc/draft-ietf-tls-hybrid-design/) or external documents.",
          "createdAt": "2023-11-08T08:57:48Z",
          "updatedAt": "2023-11-08T08:57:48Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Reopening as discussed",
          "createdAt": "2024-08-12T09:59:03Z",
          "updatedAt": "2024-08-12T09:59:03Z"
        },
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need to replace I-D.cfrg-schwabe-kyber with the FIPS-203 doc reference too\r\n\r\n```\r\n        <reference anchor=\"FIPS203\" target=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf\">\r\n          <front>\r\n            <title>Module-Lattice-Based Key-Encapsulation Mechanism Standard</title>\r\n            <author>\r\n              <organization>National Institute of Standards and Technology (NIST)</organization>\r\n            </author>\r\n            <date year=\"2024\" month=\"August\" day=\"13\"/>\r\n          </front>\r\n          <seriesInfo name=\"NIST\" value=\"Federal Information Processing Standards\"/>\r\n        </reference>\r\n```",
          "createdAt": "2024-08-14T14:30:24Z",
          "updatedAt": "2024-08-14T14:30:24Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Yup, that\u2019s exactly what I\u2019m doing right now\r\n\r\n-- \r\nKris Kwiatkowski\r\nCryptography Dev\r\n\r\n\r\n\r\n\r\n> On 14 Aug 2024, at 09:30, Panos K. ***@***.***> wrote:\r\n> \r\n> \r\n> We need to replace I-D.cfrg-schwabe-kyber with the FIPS-203 doc reference too\r\n> <reference anchor=\"FIPS203\" target=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf\">\r\n> <front>\r\n> <title>Module-Lattice-Based Key-Encapsulation Mechanism Standard</title>\r\n> <author>\r\n> <organization>National Institute of Standards and Technology (NIST)</organization>\r\n> </author>\r\n> <date year=\"2024\" month=\"August\" day=\"13\"/>\r\n> </front>\r\n> <seriesInfo name=\"NIST\" value=\"Federal Information Processing Standards\"/>\r\n> </reference>\r\n> \r\n> \u2014\r\n> Reply to this email directly, view it on GitHub, or unsubscribe.\r\n> You are receiving this because you modified the open/close state.Message ID: ***@***.***>\r\n\r\n",
          "createdAt": "2024-08-14T14:32:10Z",
          "updatedAt": "2024-08-14T14:32:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy85mU1r0",
          "commit": {
            "abbreviatedOid": "a3937fa"
          },
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I suggest to revert this commit. The reason as stated in https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-kyber/issues/11#issuecomment-1797476565 \r\n\r\n[draft-kwiatkowski-tls-ecdhe-kyber](https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-kyber) was to only get a temporary identifier to negotiate in TLS 1.3. This draft serves as the necessary \"stable reference\" to get the identifier through the \"Expert Review process\". It should not be considered as a draft that will keep getting updated and ratified.\r\n\r\n[draft-ietf-tls-hybrid-design](https://datatracker.ietf.org/doc/draft-ietf-tls-hybrid-design/) was agreed in the TLS WG to be the standards draft which will give us the identifiers for the final ML-KEM spec like `secp392-mlkem768` or `secp392-mlkem1024` or `x25519-mlkem768`. ",
          "createdAt": "2023-11-07T03:18:39Z",
          "updatedAt": "2023-11-07T03:18:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOJfxSy854XqzE",
      "title": "Replace reference I-D.cfrg-schwabe-kyber with FIPS-203",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/15",
      "state": "MERGED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #14",
      "createdAt": "2024-08-14T14:34:15Z",
      "updatedAt": "2024-08-14T15:08:08Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "097955264cfeaaa5a6ce0a854d9e11cd26752062",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/ref",
      "headRefOid": "42fce9960899388aa1c9de9e46be5568638390b5",
      "closedAt": "2024-08-14T15:08:08Z",
      "mergedAt": "2024-08-14T15:08:08Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "a772c7ed8509a88abdb80a8714f83c053ac8dc10"
      },
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@csosto-pk good for you?",
          "createdAt": "2024-08-14T14:40:46Z",
          "updatedAt": "2024-08-14T14:40:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOJfxSy854ejAw",
      "title": "Remove all mentions of temporary codepoint",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/18",
      "state": "MERGED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-15T15:04:13Z",
      "updatedAt": "2024-08-16T01:58:11Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "91e9f22e2b6e92ee6ec1e7ce904d65ffb40ee044",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/final_03",
      "headRefOid": "21fdfc8b805c446fabeb47290582d27da4c2a84e",
      "closedAt": "2024-08-16T01:58:07Z",
      "mergedAt": "2024-08-16T01:58:07Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "da9a7bafb875c3992d3d0d827d8d8df9f557d557"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86FjSlE",
          "commit": {
            "abbreviatedOid": "21fdfc8"
          },
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-15T15:13:21Z",
          "updatedAt": "2024-08-15T15:13:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOJfxSy855PQn4",
      "title": "Add X25519MLKEM768",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/20",
      "state": "MERGED",
      "author": "bwesterb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-23T11:56:40Z",
      "updatedAt": "2024-08-26T01:52:24Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "019af17b65bdf5d8606605023976f998b421912e",
      "headRepository": "bwesterb/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "bas/merge",
      "headRefOid": "e20d0f287bcd63e70e8f692f234206437cae831e",
      "closedAt": "2024-08-26T01:21:39Z",
      "mergedAt": "2024-08-26T01:21:39Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "c3028444bac5280b71d364b1a374072f46447225"
      },
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Perfect! Thanks.\r\nI'll start requesting codepoints now.",
          "createdAt": "2024-08-26T01:21:04Z",
          "updatedAt": "2024-08-26T01:52:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86GiCuq",
          "commit": {
            "abbreviatedOid": "174a5d9"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T12:04:56Z",
          "updatedAt": "2024-08-23T12:08:10Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nThis draft defines X25519MLKEM768 and SecP256r1MLKEM768, two hybrid key agreements for TLS 1.3 that combines\r\n```",
              "createdAt": "2024-08-23T12:04:56Z",
              "updatedAt": "2024-08-23T12:08:10Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nBoth groups enable the derivation of TLS session keys using FIPS-approved schemes. NIST's\r\n```",
              "createdAt": "2024-08-23T12:05:32Z",
              "updatedAt": "2024-08-23T12:08:10Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nThe ECDHE share is the serialized value of\r\n```",
              "createdAt": "2024-08-23T12:06:44Z",
              "updatedAt": "2024-08-23T12:08:10Z"
            },
            {
              "originalPosition": 168,
              "body": "```suggestion\r\n : 25500 (0x639C)\r\n```\r\n\r\ndidn\u2019t we discuss 0x11ec?",
              "createdAt": "2024-08-23T12:08:05Z",
              "updatedAt": "2024-08-23T12:08:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86GiNfp",
          "commit": {
            "abbreviatedOid": "174a5d9"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T12:29:38Z",
          "updatedAt": "2024-08-23T12:29:39Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "First time I heard that one.",
              "createdAt": "2024-08-23T12:29:38Z",
              "updatedAt": "2024-08-23T12:29:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86GjY7A",
          "commit": {
            "abbreviatedOid": "e31002e"
          },
          "author": "jschanck",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T14:41:59Z",
          "updatedAt": "2024-08-23T14:41:59Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I floated 0x11ec  it on Signal. It looks like \"0x concat ec\". I'm not attached to it.",
              "createdAt": "2024-08-23T14:41:59Z",
              "updatedAt": "2024-08-23T14:41:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86Gjjuj",
          "commit": {
            "abbreviatedOid": "174a5d9"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T15:02:22Z",
          "updatedAt": "2024-08-23T15:02:23Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Ah! Sorry, missed that. I like it.",
              "createdAt": "2024-08-23T15:02:22Z",
              "updatedAt": "2024-08-23T15:02:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOJfxSy856iG8B",
      "title": "Fix FIPS 203 section reference",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/21",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The encapsulation key check (and the rest of encapsulation) is defined in 7.2, not 7.3.",
      "createdAt": "2024-09-05T14:09:19Z",
      "updatedAt": "2024-09-09T00:03:49Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "b4af26cefb9519215a0a6664b4bbb5abb7876a8f",
      "headRepository": "davidben/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "encap-section",
      "headRefOid": "192d557f90b05025f036a48313a13954ad1c1ae0",
      "closedAt": "2024-09-09T00:03:48Z",
      "mergedAt": "2024-09-09T00:03:48Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "2128d6c2aa2d5bf1572c01f636a05ec0417b0c81"
      },
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Thanks, Mate!",
          "createdAt": "2024-09-09T00:03:46Z",
          "updatedAt": "2024-09-09T00:03:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86IFtWN",
          "commit": {
            "abbreviatedOid": "192d557"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-05T14:12:21Z",
          "updatedAt": "2024-09-05T14:12:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOJfxSy8562UbA",
      "title": "Add P-384 combined with ML-KEM-1024",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/22",
      "state": "MERGED",
      "author": "tomato42",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-09T12:58:09Z",
      "updatedAt": "2024-09-10T17:20:11Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "7dbf6e02a5c0e3e000f9ea844718ebe7983e9057",
      "headRepository": "tomato42/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "ml-kem-1024",
      "headRefOid": "615782a165b38ab151faf361ef8a869bfe50d04c",
      "closedAt": "2024-09-10T17:13:25Z",
      "mergedAt": "2024-09-10T17:13:25Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "af0f1eeaa1d7cde20b8130665a58f0e3b00f0241"
      },
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Thanks, I suggest we wait with IANA request until it we know if code point should be \"recommended\" or not.",
          "createdAt": "2024-09-10T17:13:04Z",
          "updatedAt": "2024-09-10T17:13:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86Ikyxq",
          "commit": {
            "abbreviatedOid": "ac4322d"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "First pass",
          "createdAt": "2024-09-10T04:40:43Z",
          "updatedAt": "2024-09-10T04:57:33Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "three",
              "createdAt": "2024-09-10T04:40:44Z",
              "updatedAt": "2024-09-10T04:57:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86IrARM",
          "commit": {
            "abbreviatedOid": "ac4322d"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-10T16:05:59Z",
          "updatedAt": "2024-09-10T16:05:59Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "right, fixed.",
              "createdAt": "2024-09-10T16:05:59Z",
              "updatedAt": "2024-09-10T16:05:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOJfxSy85-XYbi",
      "title": "document that error checking still needs to be performed",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/23",
      "state": "MERGED",
      "author": "tomato42",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "All algorithms have inputs that are publicly invalid (be it ECDH, X25519, or ML-KEM), document that this error checking still needs to be performed and how errors need to be handled.",
      "createdAt": "2024-10-11T17:06:25Z",
      "updatedAt": "2024-10-15T15:15:59Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "f5275e17fa023de364e4c696528b40152d43ce02",
      "headRepository": "tomato42/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "alerts",
      "headRefOid": "a23fc698cc661c5c6b3a08dce7202b027acb42e7",
      "closedAt": "2024-10-15T12:44:19Z",
      "mergedAt": "2024-10-15T12:44:19Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "1247554223796ba68ba9afea3cc89ab619af0982"
      },
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@tomato42 thank you for your understanding and perseverance.\r\nThank you all. \r\n",
          "createdAt": "2024-10-15T12:44:00Z",
          "updatedAt": "2024-10-15T12:44:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86M3N1k",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Good catch! Left some minor nitpicks.",
          "createdAt": "2024-10-11T17:32:06Z",
          "updatedAt": "2024-10-11T17:35:49Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nFor all groups, both client and server MUST check if the peer's key share\r\n```",
              "createdAt": "2024-10-11T17:32:06Z",
              "updatedAt": "2024-10-11T17:35:50Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nin Section 7.3 of {{FIPS203}} on the server's encapsulated key,\r\n```",
              "createdAt": "2024-10-11T17:32:31Z",
              "updatedAt": "2024-10-11T17:35:50Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nfor the classical part, as described in {{Section 4.2.8.2 of !RFC8446}},\r\n```\r\n\r\n(The Markdown thing is clever and knows how to linkify `{{Section X of Y}}` when Y is an IETF document.)",
              "createdAt": "2024-10-11T17:33:15Z",
              "updatedAt": "2024-10-11T17:35:50Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\ncheck described in {{Section 7.4.2 of !RFC8446}} and abort the\r\n```",
              "createdAt": "2024-10-11T17:33:27Z",
              "updatedAt": "2024-10-11T17:35:50Z"
            },
            {
              "originalPosition": 8,
              "body": "This might need a \"where applicable\" or \"For all groups that use secp256r1 or secp384r1\" or something like that, since it doesn't apply to the X25519 one.",
              "createdAt": "2024-10-11T17:34:47Z",
              "updatedAt": "2024-10-11T17:35:50Z"
            },
            {
              "originalPosition": 23,
              "body": "Similarly, this might want a \"where applicable\" or a reference to X25519 or something.",
              "createdAt": "2024-10-11T17:35:18Z",
              "updatedAt": "2024-10-11T17:35:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3VOj",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T17:52:29Z",
          "updatedAt": "2024-10-11T17:52:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "That's a more generic issue with the document.... I can fix it, but if we decide that this should be done, I think a separate patch that fixes it everywhere will be better.",
              "createdAt": "2024-10-11T17:52:30Z",
              "updatedAt": "2024-10-11T17:52:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3VR7",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T17:52:39Z",
          "updatedAt": "2024-10-11T17:52:39Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "same as in the other case",
              "createdAt": "2024-10-11T17:52:39Z",
              "updatedAt": "2024-10-11T17:52:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3V2z",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T17:54:20Z",
          "updatedAt": "2024-10-11T17:54:20Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "no, it does: an all zero key share for X25519 is invalid too",
              "createdAt": "2024-10-11T17:54:20Z",
              "updatedAt": "2024-10-11T17:54:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3WxY",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T17:56:55Z",
          "updatedAt": "2024-10-11T17:56:55Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "No, section 7.4.2 asks for an all-zero check on X25519 and X448 too\r\n(I mean, we can argue if it's necessary given the properties of X25519, but since it's already in for the pure X25519, I don't think we should change the semantics for the hybrid)",
              "createdAt": "2024-10-11T17:56:55Z",
              "updatedAt": "2024-10-11T17:56:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3W9w",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T17:57:27Z",
          "updatedAt": "2024-10-11T17:57:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "done",
              "createdAt": "2024-10-11T17:57:27Z",
              "updatedAt": "2024-10-11T17:57:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3W-w",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T17:57:30Z",
          "updatedAt": "2024-10-11T17:57:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "fixed",
              "createdAt": "2024-10-11T17:57:30Z",
              "updatedAt": "2024-10-11T17:57:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3fAD",
          "commit": {
            "abbreviatedOid": "56dd7b0"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T18:20:31Z",
          "updatedAt": "2024-10-11T18:23:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "It is, but section 4.2.8.2 doesn't discuss the all zero key share. That comes from 7.4.2. Though I suppose the section does actually discuss X25519. It just doesn't prescribe any checks at all.\r\n\r\nHow about:\r\n\r\n> For all groups, both the client and server must process the classical part as described in ..., including all validity checks.",
              "createdAt": "2024-10-11T18:20:31Z",
              "updatedAt": "2024-10-11T18:23:27Z"
            },
            {
              "originalPosition": 23,
              "body": "No, that's the opposite what I'm saying. I'm saying this text makes sense for X25519, but it's off for P-256 and P-384 because 7.4.2 does not describe any checks for P-256 and P-384. Perhaps:\r\n\r\n> For all groups, both client and server MUST calculate the classical part of the shared secret as described in ..., including the shared secret check for X25519.",
              "createdAt": "2024-10-11T18:23:23Z",
              "updatedAt": "2024-10-11T18:24:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3qr0",
          "commit": {
            "abbreviatedOid": "56dd7b0"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T18:54:50Z",
          "updatedAt": "2024-10-11T18:54:50Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yeah, I didn't know about that. But don't worry, let's not pollute this PR with unrelated changes. I'll do it in a separate PR.",
              "createdAt": "2024-10-11T18:54:50Z",
              "updatedAt": "2024-10-11T18:54:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3s1W",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T19:01:10Z",
          "updatedAt": "2024-10-11T19:01:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "ok",
              "createdAt": "2024-10-11T19:01:10Z",
              "updatedAt": "2024-10-11T19:01:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3uq9",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T19:06:31Z",
          "updatedAt": "2024-10-11T19:06:32Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "ok, done",
              "createdAt": "2024-10-11T19:06:31Z",
              "updatedAt": "2024-10-11T19:06:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3u5-",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T19:07:15Z",
          "updatedAt": "2024-10-11T19:07:15Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "ok, then fixed for the new additions",
              "createdAt": "2024-10-11T19:07:15Z",
              "updatedAt": "2024-10-11T19:07:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3u8x",
          "commit": {
            "abbreviatedOid": "cf6bf45"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T19:07:23Z",
          "updatedAt": "2024-10-11T19:07:23Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "and fixed",
              "createdAt": "2024-10-11T19:07:23Z",
              "updatedAt": "2024-10-11T19:07:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M3vh1",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T19:09:08Z",
          "updatedAt": "2024-10-11T19:12:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I don't think this is needed.\r\n\r\nWe already state above:\r\n```\r\nFor all groups, the server MUST perform the encapsulation key check\r\ndescribed in Section 7.2 of {{FIPS203}} on the client's encapsulation\r\nkey, and abort with an illegal_parameter alert if it fails.\r\n```\r\n\r\nThe size of encapulation key is already checked there (step 1). Hence here we should just say that size of P256 and 25519 must also be checked. \r\n\r\nFor classical part you added a text ``including all validity checks``. \r\n\r\nThat should be enough.",
              "createdAt": "2024-10-11T19:12:36Z",
              "updatedAt": "2024-10-11T19:12:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M30Fv",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T19:23:09Z",
          "updatedAt": "2024-10-11T19:23:09Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "but that's encapsulation key check: i.e. PQC part only, and the NIST curves have 2 representations that an overly accepting implementation can process: uncompressed and compressed, so length checks have sense either way",
              "createdAt": "2024-10-11T19:23:09Z",
              "updatedAt": "2024-10-11T19:23:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M5qYH",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-12T15:13:20Z",
          "updatedAt": "2024-10-12T15:13:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This boils down to checking the ciphertext is 1184 bytes long, and is anyway implied as part of ML-KEM.Decaps, right?\r\n\r\nIf the point is helping the implementor, I think explicitly stating it in terms of a size check would be less confusion, because Section 7.3 has details of the dk check, which is not applicable here.",
              "createdAt": "2024-10-12T15:13:21Z",
              "updatedAt": "2024-10-12T15:13:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M7ciD",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-12T20:02:58Z",
          "updatedAt": "2024-10-12T20:02:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'm thinking of it more in terms of: when you're calling the decaps() method, remember that it can fail, if it does, report that error with an `illegal_parameter`.\r\n\r\nyes, the client key shouldn't have become malformed in memory, yes, the ciphertext passed to the method should already be correct size, but having that additional check shouldn't really be an issue",
              "createdAt": "2024-10-12T20:02:58Z",
              "updatedAt": "2024-10-12T20:02:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M_iTm",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T06:28:32Z",
          "updatedAt": "2024-10-14T06:28:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "classical -> ECDH",
              "createdAt": "2024-10-14T06:28:32Z",
              "updatedAt": "2024-10-14T06:28:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M_p2p",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T06:43:38Z",
          "updatedAt": "2024-10-14T06:43:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Nop, we already described a check for both parts - MLKEM and ECDH, both on the client and server.\r\n\r\n* PQ: The server validates a KEM public key, including checking the byte length. The client must validate the ciphertext, including checking the length.\r\n* ECDH: With your change, we already have to \"MUST process the classical part as described in {{Section 4.2.8.2 of !RFC8446}}\". That should be enough.\r\n\r\nBoth checks, if done correctly, imply that the length of the peer's key share is correct. That's it, nothing else is needed. I think the general message should be clear\u2014both the ECDH and PQ parts MUST be validated separately, as they are two completely different systems. Performing any checks on concatenation doesn't provide any guarantee.\r\n\r\nThe implementation must check if the blob with the peer's keys is long enough to avoid buffer overread. But that's unrelated.",
              "createdAt": "2024-10-14T06:43:39Z",
              "updatedAt": "2024-10-14T06:57:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M_qvR",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T06:46:01Z",
          "updatedAt": "2024-10-14T06:46:02Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "classical -> ECDH",
              "createdAt": "2024-10-14T06:46:01Z",
              "updatedAt": "2024-10-14T06:46:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86M_szn",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T06:51:36Z",
          "updatedAt": "2024-10-14T06:51:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think I agree with Fillipo. The length of the ciphertext is the only thing that's required, no need to check 'dk'. Section 7.3 of FIPS203 asks to perform additional hash on a secret key, which is both not needed and may hurt performance.",
              "createdAt": "2024-10-14T06:51:36Z",
              "updatedAt": "2024-10-14T06:51:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NBw1R",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T10:16:24Z",
          "updatedAt": "2024-10-14T10:16:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Section 7.3 of FIPS203 asks to perform additional hash on a secret key, which is both not needed and may hurt performance.\r\n\r\nwhile that may be your opinion, the fact it's specified there makes it mandatory for software running in FIPS mode, thus the operation can fail",
              "createdAt": "2024-10-14T10:16:24Z",
              "updatedAt": "2024-10-14T10:16:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NB45c",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T10:24:35Z",
          "updatedAt": "2024-10-14T10:24:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This is correct. If FIPS is required, then the check must be implemented. But it doesn't have to if FIPS is not required. This text suggests that check must be implemented even if FIPS is not required.",
              "createdAt": "2024-10-14T10:24:35Z",
              "updatedAt": "2024-10-14T10:24:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NCDq8",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T10:32:03Z",
          "updatedAt": "2024-10-14T10:32:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I interpret the proposed text differently, as \"the ciphertext check described in Section 7.3 of {{FIPS203}}\" is only the ciphertext part, not the dk part. As a meta-point, this suggests this paragraph is confusing.\r\n\r\nAlso note that the check is not in fact mandatory in FIPS approved modes:\r\n\r\n> checking of the decapsulation key need not be performed by the decapsulating party, nor with every execution of ML-KEM.Decaps\r\n\r\nIf the ciphertext length is correct, ML-KEM.Decaps *can't* fail. If it fails because a dk check fails, illegal_parameter is the wrong alert anyway, because that suggests an internal error.",
              "createdAt": "2024-10-14T10:32:03Z",
              "updatedAt": "2024-10-14T10:32:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NCpBy",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:11:43Z",
          "updatedAt": "2024-10-14T11:11:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I would just write here, to check if ciphertext has correct length and fail if not. That way the requirement will be crystal clear.",
              "createdAt": "2024-10-14T11:11:43Z",
              "updatedAt": "2024-10-14T11:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NCv8i",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:25:34Z",
          "updatedAt": "2024-10-14T11:25:34Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "done",
              "createdAt": "2024-10-14T11:25:34Z",
              "updatedAt": "2024-10-14T11:25:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NCv-7",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:25:39Z",
          "updatedAt": "2024-10-14T11:25:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "done",
              "createdAt": "2024-10-14T11:25:39Z",
              "updatedAt": "2024-10-14T11:25:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NCw3N",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:27:14Z",
          "updatedAt": "2024-10-14T11:27:14Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "OK, removed the length checking paragraph",
              "createdAt": "2024-10-14T11:27:14Z",
              "updatedAt": "2024-10-14T11:27:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NC4TL",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:36:50Z",
          "updatedAt": "2024-10-14T11:36:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "You're ignoring the sentence right after it: \"Instead, assurance that this\r\ncheck has been performed can be acquired through other means (see SP 800-227 [1 ]).\"\r\n\r\nSo, what it says, is that correctness of the ML-KEM decapsulation key has to be assured. _One way_ of doing that is through checking the hash. \r\n\r\nRewrote it to make it explicit that it's about the whole decapsulation operation.",
              "createdAt": "2024-10-14T11:36:51Z",
              "updatedAt": "2024-10-14T11:36:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NC5LK",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:38:44Z",
          "updatedAt": "2024-10-14T11:38:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The decapsulation check is simply not required if the key pair has been generated on the spot, as it is here. TLS does allow reuse of key shares: we should add a sentence to say we shouldn't with ML-KEM.",
              "createdAt": "2024-10-14T11:38:44Z",
              "updatedAt": "2024-10-14T11:38:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NC7t3",
          "commit": {
            "abbreviatedOid": "c33aff0"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:43:19Z",
          "updatedAt": "2024-10-14T11:43:20Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Do we actually need those checks?",
              "createdAt": "2024-10-14T11:43:19Z",
              "updatedAt": "2024-10-14T11:43:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDDih",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T11:57:46Z",
          "updatedAt": "2024-10-14T11:57:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I didn't ignore it, I just think FIPS assurances are somewhat out of scope for a TLS draft. Anyway, for ephemeral keys, that assurance is provided by the regrettably mandatory pairwise consistency check. Also, if the ML-KEM decapsulation key is incorrect (how, if it was just generated?), then illegal_parameter is the wrong alert. I definitely disagree with the proposed text as-is now, because it makes it sound like the TLS spec requires doing the dk hash.\r\n\r\nDisallowing key share reuse sounds great, by the way. (But maybe a different PR? @bwesterb can you send one?)",
              "createdAt": "2024-10-14T11:57:46Z",
              "updatedAt": "2024-10-14T11:57:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDHA8",
          "commit": {
            "abbreviatedOid": "c33aff0"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:02:10Z",
          "updatedAt": "2024-10-14T12:02:10Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "They are specified in the relevant standards, so yes.\r\nDon't want to do them? Then don't. There's no IETF police that will chase you if you don't follow the RFC guidelines.",
              "createdAt": "2024-10-14T12:02:10Z",
              "updatedAt": "2024-10-14T12:02:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDKR4",
          "commit": {
            "abbreviatedOid": "c33aff0"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:06:49Z",
          "updatedAt": "2024-10-14T12:06:49Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The all-zero check is optional (MAY) in RFC 7748. Is it made mandatory in other TLS specs? Is there a need to make it a MUST here? I think the TLS KDF ensures contributory behavior anyway.",
              "createdAt": "2024-10-14T12:06:49Z",
              "updatedAt": "2024-10-14T12:06:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDUfX",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:19:03Z",
          "updatedAt": "2024-10-14T12:19:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "1. specifying which corners can be cut doesn't seem to me like an appropriate thing for a specification defining how to use ML-KEM in TLS, but rather something for CFRG; what we _should_ specify is best practice, it's not like we can enforce particular behaviour anyway\r\n2. I see only two ways to handle errors in decapsulation:\r\n   1. we do the length check outside the cryptographic implementation (the call to `decaps()`), and then we can translate the returned error from `decaps()` to `internal_error`\r\n   2. we delegate all error checking to the cryptographic implementation, and then translate all errors from `decaps()` to `illegal_parameter`",
              "createdAt": "2024-10-14T12:19:03Z",
              "updatedAt": "2024-10-14T12:19:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDV2I",
          "commit": {
            "abbreviatedOid": "c33aff0"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:21:33Z",
          "updatedAt": "2024-10-14T12:21:33Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "@FiloSottile rfc8446 makes it a MUST",
              "createdAt": "2024-10-14T12:21:33Z",
              "updatedAt": "2024-10-14T12:21:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDXQu",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:23:23Z",
          "updatedAt": "2024-10-14T12:23:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> we delegate all error checking to the cryptographic implementation\r\n\r\nGiven that the vast majority of cryptographic implementations are still unfortunately C, I wish you good luck with doing any meaningful check on the lengths of buffers. The only way to achieve it then is to do the TLS parsing in the cryptographic implementation, which I'd say is also quite ill advised.",
              "createdAt": "2024-10-14T12:23:23Z",
              "updatedAt": "2024-10-14T12:23:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDZ07",
          "commit": {
            "abbreviatedOid": "c33aff0"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:27:27Z",
          "updatedAt": "2024-10-14T12:27:27Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "That can be reconsidered here.",
              "createdAt": "2024-10-14T12:27:27Z",
              "updatedAt": "2024-10-14T12:27:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDbwM",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:30:57Z",
          "updatedAt": "2024-10-14T12:30:57Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@bwesterb key shares aren't null-terminated strings, it's an opaque binary blob, any remotely sane API will pass it around with the associated length....",
              "createdAt": "2024-10-14T12:30:57Z",
              "updatedAt": "2024-10-14T12:30:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDb2y",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:31:09Z",
          "updatedAt": "2024-10-14T12:31:10Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "My concern here is avoiding adding a MUST that makes it sound like a useless check is mandatory, and secondarily avoiding confusing implementers. I disagree that avoiding useless (and, again, not mandatory) FIPS checks amounts to cutting corners.\r\n\r\nTo be clear, I am only talking about the dk check, I think either way of specifying the ciphertext length check is fine.",
              "createdAt": "2024-10-14T12:31:09Z",
              "updatedAt": "2024-10-14T12:31:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDihF",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T12:42:01Z",
          "updatedAt": "2024-10-14T12:42:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> any remotely sane API will pass it around with the associated length....\r\n\r\nThe requirement comes from FIPS 203, which requires that the implementation checks the lengths of the provided ciphertext, etc.\r\n\r\nIn C the most natural API for ML-KEM-768 is to simply pass a pointer to the start of the 1088 byte ciphertext. The implicit contract with the caller is that the ciphertext is there, and it can indeed read the full 1088 bytes. This is not enforced by the language.\r\n\r\nYou could also write the API where you pass a pointer, and an explicit length. There is again an implicit contract:  the length parameter should indeed correspond to the actual length of the buffer pointed to. This is not enforced by the language.",
              "createdAt": "2024-10-14T12:42:01Z",
              "updatedAt": "2024-10-14T12:42:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NDtbF",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T13:00:17Z",
          "updatedAt": "2024-10-14T13:00:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Sorry, but I'll need a little bit more than \"because I say so\" for me to ignore NIST requirements.\r\n\r\nand, frankly, I'm rather bewildered about all this opposition to _input checks for attacker controlled values_",
              "createdAt": "2024-10-14T13:00:17Z",
              "updatedAt": "2024-10-14T13:00:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86ND6YP",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T13:13:18Z",
          "updatedAt": "2024-10-14T13:13:18Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "To start, I think I did not yet thank you for having a look and trying to get these standards in the best possible shape. Thank you.\r\n\r\nNow:\r\n\r\n> and, frankly, I'm rather bewildered about all this opposition to input checks for attacker controlled values\r\n\r\nEveryone agrees that the length of the keyshares need to be checked. The additional encapsulation and decapsulation key checks were rather controversial last minute additions to FIPS 203, and arguments in their favour do not apply to TLS.\r\n\r\n> Sorry, but I'll need a little bit more than \"because I say so\" for me to ignore NIST requirements.\r\n\r\nI do not believe we used an authority argument. Please, be courteous and assume good faith.",
              "createdAt": "2024-10-14T13:13:18Z",
              "updatedAt": "2024-10-14T13:13:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NECnH",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T13:25:59Z",
          "updatedAt": "2024-10-14T13:25:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yeah, let's back up, maybe we are speaking past each other?\r\n\r\nI think we all agree on the input check for the attacker controlled value, which is the length check on the ciphertext. It's good that this PR makes it explicit.\r\n\r\nAlso, although I have my interpretation of the interaction between the required pair-wise check and the FIPS assurance requirement, I don't think we are arguing for you to ignore any requirement. NIST is free to apply *extra* checks beyond IETF ones. It does indeed in many places.\r\n\r\nMyself, I am just saying I don't want the IETF specification to mandate, or sound like it mandates, the internal decapsulation key hash which for ephemeral keys is arguably redundant.",
              "createdAt": "2024-10-14T13:25:59Z",
              "updatedAt": "2024-10-14T13:25:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NF-Sk",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T16:38:58Z",
          "updatedAt": "2024-10-14T16:38:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> The additional encapsulation and decapsulation key checks were rather controversial last minute additions to FIPS 203, and arguments in their favour do not apply to TLS.\r\n\r\nmy point is, that this draft _will_ be used with FIPS certified modules that _may_ fail in this way (however unlikely), so I think it's better to have specification that can handle that situation\r\n\r\n> I do not believe we used an authority argument. Please, be courteous and assume good faith.\r\n\r\nI did not assume bad faith, while the tone was because of frustration, my intention was to ask to provide a solid justification for ignoring explicit requirements of the standard.\r\n\r\nAnd yes, I agree, it also looks to me like it's a case of \"crossing all the t's and dotting all the i's\" or \"belt and suspenders\" approach, but if they decided to add it, it's likely that they had a good reason for it. And even if that reason was very flimsy, there's very little downside in performing the additional checks on the private key. Unfortunately, I'm afraid we'll need to wait for SP 800-227 actually getting published to know for sure.\r\n\r\n> Also, although I have my interpretation of the interaction between the required pair-wise check and the FIPS assurance requirement, I don't think we are arguing for you to ignore any requirement. NIST is free to apply extra checks beyond IETF ones. It does indeed in many places.\r\n\r\nthen lets be explicit about it, and state that \"If the implementation of ML-KEM decapsulation in use can return errors, because of checks specified in section 7.3 of FIPS 203, they MUST cause a connection abort with illegal_parameter alert. If it can't, then the length check MUST be performed, and if it fails, cause connection abort with an illegal_parameter alert.\"?",
              "createdAt": "2024-10-14T16:38:58Z",
              "updatedAt": "2024-10-14T16:39:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NGHgc",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T16:56:16Z",
          "updatedAt": "2024-10-14T16:56:16Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> then lets be explicit about it, and state that \"If the implementation of ML-KEM decapsulation in use can return errors, because of checks specified in section 7.3 of FIPS 203, they MUST cause a connection abort with illegal_parameter alert. If it can't, then the length check MUST be performed, and if it fails, cause connection abort with an illegal_parameter alert.\"?\r\n\r\nI still think illegal_parameter is the wrong alert for private key generation errors that have nothing to do with what the peer sent.\r\n\r\nHow about \"The length of the ciphertext MUST be checked to match the expected size, and if it doesn't the connection MUST be aborted with an illegal_parameter alert. If ML-KEM decapsulation fails for any other reason, the connection MUST be aborted with an internal_error alert.\"",
              "createdAt": "2024-10-14T16:56:16Z",
              "updatedAt": "2024-10-14T16:56:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NGKE3",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T17:02:17Z",
          "updatedAt": "2024-10-14T17:02:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@kriskwiatkowski is that OK for you?",
              "createdAt": "2024-10-14T17:02:17Z",
              "updatedAt": "2024-10-14T17:02:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NLBJ3",
          "commit": {
            "abbreviatedOid": "639a846"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T07:59:21Z",
          "updatedAt": "2024-10-15T07:59:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'm OK with checking ciphertext length. But to require a check of ``dk`` as per section 7.3 is maybe too much. The intention is not to say \"don't do it\", but also I don't believe we should be saying \"You have to do it even if it makes no sense\".\r\n\r\n> my point is, that this draft will be used with FIPS-certified modules that may fail in this way (however unlikely), so I think it's better to have specifications that can handle that situation\r\n\r\nI understand that you're trying to address a situation where a FIPS-certified module fails because the check on \"dk\" fails. I believe that the \"illegal_parameter\" alert indicates a problem with the protocol syntax or handshake. In our case, if the check on \"dk\" fails, then it means that \"dk\" was corrupted in some way. I think the \"internal_error\" alert is the most appropriate for this case.",
              "createdAt": "2024-10-15T07:59:21Z",
              "updatedAt": "2024-10-15T08:00:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NLxwb",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T09:16:40Z",
          "updatedAt": "2024-10-15T09:16:40Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@kriskwiatkowski it sounds we agree, I think @tomato42 was asking if you're ok with the text I am suggesting in https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/23#discussion_r1799832620.\r\n\r\n> The length of the ciphertext MUST be checked to match the expected size, and if it doesn't the connection MUST be aborted with an illegal_parameter alert. If ML-KEM decapsulation fails for any other reason, the connection MUST be aborted with an internal_error alert.",
              "createdAt": "2024-10-15T09:16:40Z",
              "updatedAt": "2024-10-15T09:16:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NMDx9",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T09:42:54Z",
          "updatedAt": "2024-10-15T09:42:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yep, this text would be perfect in my opinion.",
              "createdAt": "2024-10-15T09:42:54Z",
              "updatedAt": "2024-10-15T09:42:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NNb1x",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T11:57:33Z",
          "updatedAt": "2024-10-15T11:57:34Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> I think @tomato42 was asking if you're ok with the text I am suggesting in https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/23#discussion_r1799832620.\r\n\r\nprecisely that :)",
              "createdAt": "2024-10-15T11:57:33Z",
              "updatedAt": "2024-10-15T11:57:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86NNdXU",
          "commit": {
            "abbreviatedOid": "a5bdbb7"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T12:00:23Z",
          "updatedAt": "2024-10-15T12:00:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I've rephrased it slightly so that it matches the paragraphs near it",
              "createdAt": "2024-10-15T12:00:23Z",
              "updatedAt": "2024-10-15T12:00:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOJfxSy85-tuAh",
      "title": "fix eaten characters/words",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/24",
      "state": "MERGED",
      "author": "tomato42",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "story as old as time: noticing typos right after publication...",
      "createdAt": "2024-10-15T18:19:14Z",
      "updatedAt": "2024-10-15T22:09:39Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "1247554223796ba68ba9afea3cc89ab619af0982",
      "headRepository": "tomato42/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "typo-fix",
      "headRefOid": "011cbccb5c5ea7d4fd1cc879346cbaa929bb1b18",
      "closedAt": "2024-10-15T20:21:20Z",
      "mergedAt": "2024-10-15T20:21:20Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "5206c52910b9520f3d6809c5f31e3a0820c1c01b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86NSCKn",
          "commit": {
            "abbreviatedOid": "011cbcc"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-15T18:59:38Z",
          "updatedAt": "2024-10-15T18:59:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDOJfxSy86AqTBg",
      "title": "Forbid reuse of ephemeral private key",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/25",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Forbid reuse of ephemeral private key.",
      "createdAt": "2024-11-01T18:28:42Z",
      "updatedAt": "2024-12-11T16:23:59Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "0eee72f28caf4a8c06bc9d661c7e39bf0271a424",
      "headRepository": "emanjon/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "patch-1",
      "headRefOid": "84970ccb910d7d5446a8d3b03a4529a0c1d1e906",
      "closedAt": "2024-12-11T16:23:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Let's wait for a decision from TLS chairs before merging it. Reuse is bad, but it would be a better if this requirement covers more than 3 codepoints.",
          "createdAt": "2024-11-04T08:38:46Z",
          "updatedAt": "2024-11-04T08:38:46Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "NONE",
          "body": "> Let's wait for a decision from TLS chairs before merging it. Reuse is bad, but it would be a better if this requirement covers more than 3 codepoints.\r\n\r\nYes, Let's hope for a general MUST NOT. But just forbidding reuse for PQC key exchange or these 3 codepoints would be a big step forward. My expectation is that X25519MLKEM768 will dominate future TLS and should be made MTI in the future.\r\n\r\nI don't think reuse should be up to the endpoint. I would like to know that the endpoint I communicate with is not allowed too do reuse. If someone want to do reuse, I think that should be visible using something like https://www.ietf.org/archive/id/draft-rhrd-tls-tls13-visibility-01.txt\r\n\r\n",
          "createdAt": "2024-11-04T09:03:48Z",
          "updatedAt": "2024-11-04T09:03:48Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "+1, absolutely. This is definitely needed in general.",
          "createdAt": "2024-11-04T09:57:49Z",
          "updatedAt": "2024-11-04T09:57:49Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that it's good if reuse is disallowed, but we can't change that for existing key agreements immediately. Instead, I see we could require this for new key agreement such as these in this document.",
          "createdAt": "2024-11-04T13:22:42Z",
          "updatedAt": "2024-11-04T13:22:42Z"
        },
        {
          "author": "ctz",
          "authorAssociation": "NONE",
          "body": "I feel like the text already in https://datatracker.ietf.org/doc/html/draft-ietf-tls-hybrid-design covers this in more precision -- maybe this change could re-refer to that part (6-ish paragraph in section 3.2) rather than restating it? ",
          "createdAt": "2024-11-05T15:48:39Z",
          "updatedAt": "2024-11-05T15:48:39Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "NONE",
          "body": "@ctz I read 3.2 of draft-ietf-tls-hybrid-design and could not see where it forbid reuse. Could you quote.",
          "createdAt": "2024-11-05T16:42:50Z",
          "updatedAt": "2024-11-05T16:42:50Z"
        },
        {
          "author": "ctz",
          "authorAssociation": "NONE",
          "body": "I was thinking of this part:\r\n\r\n> the KeyShareEntry.key_exchange values MUST be generated in one of the following two ways:\r\n\r\nI don't think either of the two specified ways admits reuse.\r\n\r\nThen again, there's some other text at the end of section 2 that more specifically describes and allows for reuse. I'm probably wrong here.",
          "createdAt": "2024-11-05T16:50:35Z",
          "updatedAt": "2024-11-05T16:50:35Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Let's handle this as much as possible in the [draft-ietf-tls-hybrid-design](https://datatracker.ietf.org/doc/html/draft-ietf-tls-hybrid-design), so that it covers other codepoints that may potentially be introduced in the future.\r\nThis document may refer the corresponding section in draft-ietf-tls-hybrid-design once text is added.",
          "createdAt": "2024-11-10T12:53:30Z",
          "updatedAt": "2024-11-10T12:53:30Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "I've submitted PR with this text to draft-ietf-tls-hybrid-design \r\n\r\nhttps://github.com/dstebila/draft-ietf-tls-hybrid-design/pull/39",
          "createdAt": "2024-11-29T00:01:06Z",
          "updatedAt": "2024-11-29T00:01:06Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@emanjon  https://github.com/dstebila/draft-ietf-tls-hybrid-design/pull/39 is merged. I hope that this solves the problem.\r\nFeel free to re-open PR if something else needs to be added.",
          "createdAt": "2024-12-11T16:23:59Z",
          "updatedAt": "2024-12-11T16:23:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86PsPBF",
          "commit": {
            "abbreviatedOid": "4e802c9"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-01T19:14:28Z",
          "updatedAt": "2024-11-01T19:14:28Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "s/channesl/channels/\r\ns/Reuse also have/Reuse also has/\r\n",
              "createdAt": "2024-11-01T19:14:28Z",
              "updatedAt": "2024-11-01T19:14:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86PsTvI",
          "commit": {
            "abbreviatedOid": "4e802c9"
          },
          "author": "ghen2",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-01T19:28:51Z",
          "updatedAt": "2024-11-01T19:28:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Can \"in different connections\" be included in the first sentence already?\r\n\r\nThere's a valid case to reuse key shares for (different combinations of) the same algorithm *in the same connection*, like the Rustls implementation is doing for X25519 and X25519MLKEM768: https://github.com/rustls/rustls/pull/2136\r\n\r\nWhile this specification appears to allow it, it's not 100% unambiguous.",
              "createdAt": "2024-11-01T19:28:51Z",
              "updatedAt": "2024-11-01T19:28:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86PuBxH",
          "commit": {
            "abbreviatedOid": "4e802c9"
          },
          "author": "emanjon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-02T07:19:50Z",
          "updatedAt": "2024-11-02T07:19:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "fixed",
              "createdAt": "2024-11-02T07:19:50Z",
              "updatedAt": "2024-11-02T07:19:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86PuBzH",
          "commit": {
            "abbreviatedOid": "4e802c9"
          },
          "author": "emanjon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-02T07:21:16Z",
          "updatedAt": "2024-11-02T07:21:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Good point. fixed. Agree that this is a valid use of \"reuse\" without any security implications. ",
              "createdAt": "2024-11-02T07:21:16Z",
              "updatedAt": "2024-11-02T07:21:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86QBRi4",
          "commit": {
            "abbreviatedOid": "84970cc"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-05T17:13:29Z",
          "updatedAt": "2024-11-05T17:13:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDOJfxSy86Ex6Nm",
      "title": "X25519MLKEM768 to MLKEM768X25519",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/26",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is done to align with the requirement described in section 3.2 of draft-ietf-tls-hybrid-design-11.",
      "createdAt": "2024-12-11T00:00:28Z",
      "updatedAt": "2025-01-15T22:09:17Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "5c011f12b5dc794db15fbd73d04d5561d822ef9f",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/swap_order",
      "headRefOid": "3a0a93662df76abe90d2503231d5dafb13efadd2",
      "closedAt": "2025-01-15T22:07:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe there is working group consensus to make this change, and X25519MLKEM768 *under that name* is widely deployed already.",
          "createdAt": "2024-12-11T00:27:46Z",
          "updatedAt": "2024-12-11T00:28:23Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Ha! I calculated (zulip + mailing list), 5 people prefer to swap, 4 people prefer not to, 2 people undecided/don't care.\r\nThe other thing we could is just to mention that the name X25519MLKEM768 is kind of exception and it is not aligned with draft-tls-hybrid. And that's it.\r\n\r\nFrankly, I would like to find consensus (whatever it is) and make the draft ready for adoption.",
          "createdAt": "2024-12-11T00:42:35Z",
          "updatedAt": "2024-12-11T00:45:30Z"
        },
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> X25519MLKEM768 is kind of exception and it is not aligned with draft-tls-hybrid. \r\n\r\nI think that is painless enough. Did it come up in the list a people objected? I don't remember. \r\n",
          "createdAt": "2024-12-11T03:15:37Z",
          "updatedAt": "2024-12-11T03:15:37Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "> > X25519MLKEM768 is kind of exception and it is not aligned with draft-tls-hybrid.\r\n> \r\n> I think that is painless enough. Did it come up in the list a people objected? I don't remember.\r\n\r\nI did \ud83e\udee3",
          "createdAt": "2024-12-11T04:28:29Z",
          "updatedAt": "2024-12-11T04:28:29Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "How about that, then? https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/27?",
          "createdAt": "2024-12-11T08:40:39Z",
          "updatedAt": "2024-12-11T13:25:47Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @davidben",
          "createdAt": "2024-12-11T11:05:47Z",
          "updatedAt": "2024-12-11T11:05:47Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@dconnolly what do you think about #27 ?",
          "createdAt": "2024-12-11T11:38:14Z",
          "updatedAt": "2024-12-11T11:38:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No strong preference on the name, as long as the wire format stays compatible. Leaving a footnote is fine with me.",
          "createdAt": "2024-12-11T15:34:12Z",
          "updatedAt": "2024-12-11T15:34:12Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "Since the wire format is the same, the codepoint is the same, it should align with -hybrid-design and have the name match the wire format, as intended",
          "createdAt": "2024-12-11T16:24:36Z",
          "updatedAt": "2024-12-11T16:24:36Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you are a developer and see these two choices:\r\n\r\n- P256MLKEM768\r\n- MLKEM768X25519\r\n\r\nThe user might think: why is the MLKEM768 in a different place? Does it matter?\r\n\r\nOf course the order is immaterial. It's less confusing if we just use the names.\r\n\r\n- P256MLKEM768\r\n- X25519MLKEM768\r\n\r\nOf course this is more confusing to the crypto engineer that need to implement this in TLS libraries. But there are many more developers picking KEMs than there are crypto engineers implementing them. We shouldn't move undue complexity to the enduser.\r\n",
          "createdAt": "2024-12-11T16:36:41Z",
          "updatedAt": "2024-12-11T16:38:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do agree it would be a poor outcome if the names were different like that. It is... unfortunate that we ended up making the wire order inconsistent but the wire order impacts fewer people than the names.",
          "createdAt": "2024-12-11T16:54:00Z",
          "updatedAt": "2024-12-11T16:54:00Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "To be clear, this is a MUST in [-hybrid-design](https://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-11.html):\r\n\r\n<img width=\"760\" alt=\"image\" src=\"https://github.com/user-attachments/assets/bdc6614c-ea3a-4cc8-965c-05e37703b87c\" />\r\n",
          "createdAt": "2024-12-11T17:29:42Z",
          "updatedAt": "2024-12-11T17:29:42Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "Strong preference for keeping X25519MLKEM768.\r\n\r\nWe already deployed it under that name and it's forever seared into our backwards-compatibility promise. golang/go#69985\r\n\r\nI also find the argument in https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/26#issuecomment-2536502901 persuasive. There are dozens (maybe less?) of implementers and tens of thousands (maybe more?) system administrators that will be exposed to these names. \r\n\r\nI'd even argue to change the overall rule to `[non-PQ][PQ]` in -hybrid-design.",
          "createdAt": "2024-12-11T17:30:12Z",
          "updatedAt": "2024-12-11T17:30:12Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "> Strong preference for keeping X25519MLKEM768.\r\n> \r\n> We already deployed it under that name and it's forever seared into our backwards-compatibility promise. [golang/go#69985](https://github.com/golang/go/issues/69985)\r\n> \r\n> I also find the argument in [#26 (comment)](https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/26#issuecomment-2536502901) persuasive. There are dozens (maybe less?) of implementers and tens of thousands (maybe more?) system administrators that will be exposed to these names.\r\n> \r\n> I'd even argue to change the overall rule to `[non-PQ][PQ]` in -hybrid-design.\r\n\r\nYou made backwards-compatibility commitments on an unstable document?",
          "createdAt": "2024-12-11T17:34:32Z",
          "updatedAt": "2024-12-11T17:34:32Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "> Strong preference for keeping X25519MLKEM768.\r\n> \r\n> We already deployed it under that name and it's forever seared into our backwards-compatibility promise. [golang/go#69985](https://github.com/golang/go/issues/69985)\r\n> \r\n> I also find the argument in [#26 (comment)](https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/26#issuecomment-2536502901) persuasive. There are dozens (maybe less?) of implementers and tens of thousands (maybe more?) system administrators that will be exposed to these names.\r\n> \r\n> I'd even argue to change the overall rule to `[non-PQ][PQ]` in -hybrid-design.\r\n\r\nAlso -hybrid-design has already gone through last call",
          "createdAt": "2024-12-11T17:35:13Z",
          "updatedAt": "2024-12-11T17:35:13Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "I deployed a security-relevant improvement to my users, the same that's deployed by browsers and CDNs, and referred to it by its current name. I stand by that choice.\r\n\r\n-hybrid-design is a sign, not a cop, and it would be a deeply sad outcome if we deliberately chose to sign up thousands of people for confusion because we feel we can't amend a last call or add a note saying it doesn't match a document that anyway AFAICT is not necessary to implement X25519MLKEM768.\r\n\r\nLooking at this thread, X25519MLKEM768 has rough consensus and running code. ",
          "createdAt": "2024-12-11T17:42:09Z",
          "updatedAt": "2024-12-11T17:42:09Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "Also, the IANA registry already has an entry for 4588 with name X25519MLKEM768.\r\n\r\nhttps://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8\r\n\r\nIt feels completely legitimate to rely on names in the IANA registry not to change. Can IANA registries be changed in a non-backwards compatible way? What would even be the point of IANA then?",
          "createdAt": "2024-12-11T17:48:47Z",
          "updatedAt": "2024-12-11T17:48:47Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@FiloSottile, _if_ we proceed with this change, then the plan is to update this name in IANA without modifying the code point value.\r\n\r\n",
          "createdAt": "2024-12-11T18:03:04Z",
          "updatedAt": "2024-12-11T18:03:04Z"
        },
        {
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@FiloSottile\r\n> Also, the IANA registry already has an entry for 4588 with name X25519MLKEM768.\r\n> \r\n> https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8\r\n> \r\n> It feels completely legitimate to rely on names in the IANA registry not to change. Can IANA registries be changed in a non-backwards compatible way? What would even be the point of IANA then?\r\n\r\nthe IDs in IANA referenced by drafts can definitely change, they're not immutable\r\n\r\nwhile I agree that changing the name is painful, providing an alias, where both `X25519MLKEM768` and `MLKEM768X25519` will work to enable the same group isn't insurmountable\r\n\r\nand just looking at gnutls, openssl and NSS I see different names for this fundamentally the same group already; hell, we've had OpenSSL refer to `secp256r1` as `prime256v1`  as basically the only implementation and the internet still managed to widely deploy it, so it's not like Go _needs_ to change the name to align it with IANA\r\n\r\nat the end of the day, the users don't care (or even know) what key exchange they use, as long as the connection works, they're happy",
          "createdAt": "2024-12-12T17:06:58Z",
          "updatedAt": "2024-12-12T17:06:58Z"
        },
        {
          "author": "rolandshoemaker",
          "authorAssociation": "NONE",
          "body": "Chiming in as a maintainer of the Go crypto libraries. While I understand the intent behind this change, I would like to add that this seems likely to cause more pain and confusion than it is likely to solve. The mismatch between the name and wire format is unfortunate, but that property is likely of importance to 1% of the people who will be exposed to the name.\r\n\r\nSwitching now, after many libraries have already deployed using the current name, and much documentation, and many blog posts have been written using the current name, feels like it'd cause significant confusion.\r\n\r\nAs a library maintainer, the idea that users don't need to worry about these naming choices strikes me as incorrect. The confusing naming choices of ciphersuites and crypto primitives, and a lack of consistency around them, turns out to be a consistent pain point for users, and for maintainers who have to answer their questions. The NIST P-256/secp256r1/prime256v1 confusion is still something we get questions about, and the RFC 8422 Appendix A \"clarifications\" have done nothing to prevent this.\r\n\r\nIn this case we are perhaps lucky that the proposed change is just reversing the order, but I would put a not insignificant amount of money on the fact that if the name changes now, I'll be fielding questions about whether X25519MLKEM768 is the same thing as MLKEM768X25519, or why we don't implement one or the other, for the foreseeable future.\r\n\r\nFor better or worse, (quite a bit of) deployed software now uses the name X25519MLKEM768, and search engines are going to perpetuate this mistake for eternity, whether or not the name is changed at this late point. ",
          "createdAt": "2024-12-12T18:25:54Z",
          "updatedAt": "2024-12-13T16:18:26Z"
        },
        {
          "author": "alexzas",
          "authorAssociation": "NONE",
          "body": "An implementer here adding hybrid MLKEM to our CryptoComply library. I must admit I initially assumed that the order of key shares is dictated by scheme name (which is correct for most other schemes) and spent several days debugging failed connections to Chrome client. \r\nI wonder if \"NIST intends to allow the 800-56C key derivation methods to apply to shared secrets of the form Z = T || Z\u2019, where T and Z\u2019 are ...in reverse order.\" should help here? \r\n\r\nMy assumption is that PQC migration will affect much wider audience, with some not even familiar with FIPS, but they might open wireshark and see inconsistency on the wire. \r\n   \r\nI hope we are still in the early days of PQC migration and can make things right.. \r\n\r\nmy 2c,\r\nAlex",
          "createdAt": "2024-12-13T13:43:00Z",
          "updatedAt": "2024-12-13T13:43:00Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I must admit I initially assumed that the order of key shares is dictated by scheme name (which is correct for most other schemes) and spent several days debugging failed connections to Chrome client.\r\n\r\nSorry about that :(.\r\n\r\n> My assumption is that PQC migration will affect much wider audience, with some not even familiar with FIPS, but they might open wireshark and see inconsistency on the wire.\r\n\r\nOn the wire these are almost uniform random blobs. Technically I can tell the order with good probability (because coefficients mod 3329 are stored in 12 bits), but I doubt a casual user would see that.\r\n\r\n",
          "createdAt": "2024-12-13T14:09:30Z",
          "updatedAt": "2024-12-13T14:09:30Z"
        },
        {
          "author": "vdukhovni",
          "authorAssociation": "NONE",
          "body": "I fail to see how the requirement on the wire order of the components matching the order of algorithms defining the hybrid translates to a requirement on the group **name**.  The group **name** `X25519MLKEM768` can easily refer the ordered algorithm pair `(MLKEM768, X25519)`, which then produce their outputs in the widely implemented order expected of the code point. The group name (bikeshed colour) could be `REDBLUE` for all it matters.\r\n\r\nLet's not change the name now unless (rather unexpectedly) the wire order is changing and a new code point is being assigned.",
          "createdAt": "2025-01-03T00:51:24Z",
          "updatedAt": "2025-01-03T00:51:24Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "IETF believes in \u201din rough consensus and running code\u201d. We may not have rough consensus here, but running code is definitely there.\r\nI'll close this PR, it seems most participants in this discussion wish not to do it (including myself now).\r\n",
          "createdAt": "2025-01-15T22:07:28Z",
          "updatedAt": "2025-01-15T22:09:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86Up3d7",
          "commit": {
            "abbreviatedOid": "3a0a936"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-11T00:20:08Z",
          "updatedAt": "2024-12-11T00:20:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJfxSy86WtVdv",
          "commit": {
            "abbreviatedOid": "3a0a936"
          },
          "author": "vdukhovni",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-01-03T01:30:54Z",
          "updatedAt": "2025-01-03T01:38:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This confuses identities with identifiers. The name is just an identifier, and so long as the group by that name is defined to be an ordered combination of `ML-KEM-768` (NIST name) and `X25519`, there is no conflict with the hybrid design draft, that draft isn't about how things are named, it is about how they're defined.\r\n\r\nSo this change feels gratuitous.",
              "createdAt": "2025-01-03T01:30:54Z",
              "updatedAt": "2025-01-03T01:38:32Z"
            },
            {
              "originalPosition": 23,
              "body": "Whatever the reason, the definition should first state the order of the two component algorithms (state the definition of the group), and only then perhaps give a rationale, or note that in that particular order the result may be better aligned with FIPS (which may or may not be true).",
              "createdAt": "2025-01-03T01:33:55Z",
              "updatedAt": "2025-01-03T01:38:32Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nand the client's X25519 ephemeral share, in that order.\r\n```\r\nThis finally is the definition of the group, though one could also state that the hybrid algorithm is an ordered combination of `ML-KEM-768` and `X25519` and the wire order is then, in accordance with hybrid-design, ML-KEM first, X25519 second.",
              "createdAt": "2025-01-03T01:34:29Z",
              "updatedAt": "2025-01-03T01:38:32Z"
            },
            {
              "originalPosition": 74,
              "body": "This part is justified, since it is reaffirming the order of the components that the group represents as identified by the group name.",
              "createdAt": "2025-01-03T01:38:07Z",
              "updatedAt": "2025-01-03T01:38:32Z"
            },
            {
              "originalPosition": 82,
              "body": "Let's not.",
              "createdAt": "2025-01-03T01:38:24Z",
              "updatedAt": "2025-01-03T01:38:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 27,
      "id": "PR_kwDOJfxSy86E0gEd",
      "title": "Exception for X25519MLKEM768 naming",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/27",
      "state": "MERGED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-11T08:40:10Z",
      "updatedAt": "2024-12-19T10:41:58Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "5c011f12b5dc794db15fbd73d04d5561d822ef9f",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/exception",
      "headRefOid": "c0dff294c61a087bd5849a3f7895f895872b2686",
      "closedAt": "2024-12-19T10:41:53Z",
      "mergedAt": "2024-12-19T10:41:53Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "0197886417fda04fded659d8611dacd2a1904914"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "This is not in compliance with [-hybrid-design](https://www.ietf.org/archive/id/draft-ietf-tls-hybrid-design-11.html):\r\n\r\n<img width=\"764\" alt=\"image\" src=\"https://github.com/user-attachments/assets/5e042535-d8aa-498a-b731-f489cdbeb42d\" />\r\n\r\n",
          "createdAt": "2024-12-11T17:30:36Z",
          "updatedAt": "2024-12-11T17:30:36Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Let's merge it as this is current state of the art.\r\nI don't think there is clear consensus regarding changing the name of X25519-MLKEM768. We will get a consensus after document is adopted.",
          "createdAt": "2024-12-19T10:41:13Z",
          "updatedAt": "2024-12-19T10:41:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86UuVwq",
          "commit": {
            "abbreviatedOid": "c0dff29"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-11T11:04:49Z",
          "updatedAt": "2024-12-11T11:04:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJfxSy86U0ES4",
          "commit": {
            "abbreviatedOid": "c0dff29"
          },
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-11T19:41:00Z",
          "updatedAt": "2024-12-11T19:41:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "LGTM",
              "createdAt": "2024-12-11T19:41:00Z",
              "updatedAt": "2024-12-11T19:41:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86U0E0F",
          "commit": {
            "abbreviatedOid": "c0dff29"
          },
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-11T19:41:30Z",
          "updatedAt": "2024-12-11T19:41:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJfxSy86VA2KU",
          "commit": {
            "abbreviatedOid": "c0dff29"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-12T15:33:42Z",
          "updatedAt": "2024-12-12T15:33:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJfxSy86VCL-Y",
          "commit": {
            "abbreviatedOid": "c0dff29"
          },
          "author": "ctz",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "This situation is unfortunate but I think this direction leaves us with the minimum amount of mess.",
          "createdAt": "2024-12-12T17:42:51Z",
          "updatedAt": "2024-12-12T17:42:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOJfxSy86FawUH",
      "title": "Compact spacing for IANA considerations",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/28",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a cosmetic change.\r\n\r\n(Also, you should consider pushing a revision of the document to get the P-384 suite out there.)",
      "createdAt": "2024-12-16T22:24:25Z",
      "updatedAt": "2024-12-16T22:44:39Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "0eee72f28caf4a8c06bc9d661c7e39bf0271a424",
      "headRepository": "martinthomson/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "patch-1",
      "headRefOid": "e991332ece6cf5eb1a0040522efc2cabe192efea",
      "closedAt": "2024-12-16T22:44:39Z",
      "mergedAt": "2024-12-16T22:44:38Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "dc3122f642b807672b7f17eeda4d394b3b021326"
      },
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson Thanks. Yes, I'll push for P384 very soon. I was hoping -03 will resolve issue around naming of X25519MLKEM768.",
          "createdAt": "2024-12-16T22:43:16Z",
          "updatedAt": "2024-12-16T22:44:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86VdTVU",
          "commit": {
            "abbreviatedOid": "e991332"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-16T22:32:43Z",
          "updatedAt": "2024-12-16T22:32:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOJfxSy86MtOB-",
      "title": "Fix up ECDH shared secret text",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/31",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #30. See #30 for details.",
      "createdAt": "2025-02-26T20:46:44Z",
      "updatedAt": "2025-03-04T06:57:43Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "4dd74c1198cabd487b56018de584ca5646c618e3",
      "headRepository": "davidben/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "ecdh-shared-secret-check",
      "headRefOid": "50850de4e11b8eb382b8f40f3807eb8285e8a0bc",
      "closedAt": "2025-03-04T06:57:43Z",
      "mergedAt": "2025-03-04T06:57:43Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "df3be576927cfd23b5c089bcd1714d405b94c09e"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "CI breakage is unrelated. See https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/32",
          "createdAt": "2025-02-26T20:49:37Z",
          "updatedAt": "2025-02-26T20:49:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> CI breakage is unrelated. See https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/32\r\n\r\nRebased",
          "createdAt": "2025-02-26T21:49:45Z",
          "updatedAt": "2025-02-26T21:49:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tomato42 Looks like your responses on the PR and the issue are different, so I'll respond to those on each separately...\r\n\r\nThis is about ECDH, not ECDSA, and even there is no connection to interoperability here. If your implementation happened to use a different ECDH specification, without this check (does such a specification exist? there are a lot of ECDH specifications, but I've never seen one that omits it), it would make no difference because this case is _not possible_.\r\n\r\nMoreover, it doesn't matter what other specifications exist because we already say to follow Section 7.4.2 of RFC 8446, which is already responsible for covering all this. If there's something missing in RFC 8446, we should fix it in rfc8446bis. But also there isn't anything missing in RFC 8446, except that maybe it would be nice to cite a more freely accessible standard for ECDH. (Though I do have access to it and can tell you it does indeed include that check.) In both this document, and in RFC 8446, an impossible case does not rise to the level of needing reiteration.\r\n\r\nI'll touch on whether it's possible for different curves in reply to your issue comment.",
          "createdAt": "2025-02-28T15:41:12Z",
          "updatedAt": "2025-02-28T15:41:12Z"
        },
        {
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> his is about ECDH, not ECDSA, and even there is no connection to interoperability here\r\n\r\nyes sorry, meant ECC, not ECDSA\r\n\r\n\r\nI don't like that we're bing explicit about x25519 checks while we're not about NIST curves.\r\n\r\n> Moreover, it doesn't matter what other specifications exist because we already say to follow Section 7.4.2 of RFC 8446, which is already responsible for covering all this.  If there's something missing in RFC 8446, we should fix it in rfc8446bis. \r\n\r\n1. the RFC8446 is also explicit about checks for X25519 and X448, not NIST curves (for those it delegates to IEEE1363)\r\n2. fixing it in 8446bis is a long delay\r\n\r\nAnd yes, _technically_ that situation can't happen, yet low level standards ask for including that check...\r\n\r\nso, while I would prefer an explicit check and reference to SP800-56A, I'll not insist on it...",
          "createdAt": "2025-03-03T14:31:10Z",
          "updatedAt": "2025-03-03T14:31:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, the difference between NIST curves and X25519 is twofold:\r\n\r\n1. X25519 has a cofactor and no check of the peer key on input, so the check is actually possible to hit\r\n2. The check in the underlying specification is optional, so if TLS wants the check to happen, it needs to say so explicitly\r\n\r\n(2) means that, in RFC 8446, this is actually load-bearing normative text, not just reiterating a requirement. Since this document cites RFC 8446, it is not load-bearing in this document (so I think it would have been fine to omit both), but because of (1), it's plausible to reiterate it here. Neither of these apply to NIST curves.\r\n\r\n> fixing it in 8446bis is a long delay\r\n\r\nWe don't necessarily have to cite 8446bis and wait for it to complete. I'm saying that if we think that the text belongs here, it certainly belongs in 8446bis and should be proposed there in parallel too. (But IMO it belongs in neither.)",
          "createdAt": "2025-03-03T14:53:27Z",
          "updatedAt": "2025-03-03T14:54:04Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, I guess (1) is slightly more subtle because it's a question of whether, in NIST curves, you check for the point at infinity (the only low order peer key) on input[*] or afterwards. You could indeed formulate NIST ECDH by saying that the point at infinity is checked after ECDH, rather than before, and then the check is also load-bearing. But this document and RFC 8446 chose to check it on input.\r\n\r\n[*] There is, technically, a goofy one-byte encoding of the point at infinity. TLS doesn't permit it. Our library doesn't even implement it at all, even in the low-level cryptographic bits, because it's pure risk.",
          "createdAt": "2025-03-03T14:55:28Z",
          "updatedAt": "2025-03-03T14:56:44Z"
        },
        {
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes, I still don't like the complete removal of the check from the text; that being said, I'm ok with it, so I'm leaving it up to @kriskwiatkowski ",
          "createdAt": "2025-03-03T15:15:54Z",
          "updatedAt": "2025-03-03T15:15:54Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Thanks. If it's up to me then, as I wrote before, I think we should not mention it here.",
          "createdAt": "2025-03-04T06:57:38Z",
          "updatedAt": "2025-03-04T06:57:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86dyw1G",
          "commit": {
            "abbreviatedOid": "50850de"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-27T10:32:57Z",
          "updatedAt": "2025-02-27T10:32:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJfxSy86d-4Jo",
          "commit": {
            "abbreviatedOid": "50850de"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-28T11:39:33Z",
          "updatedAt": "2025-02-28T11:39:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJfxSy86d_V-r",
          "commit": {
            "abbreviatedOid": "50850de"
          },
          "author": "tomato42",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "no, while indeed the `P` is not _the_ shared secret in SP 800-56A, so we may want to re-phrase it; I think we should be explicit that this check should be performed, as SP 800-56A is not the only interoperable implementation of ECDSA...",
          "createdAt": "2025-02-28T12:36:15Z",
          "updatedAt": "2025-02-28T12:36:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOJfxSy86MtPJP",
      "title": "Fix CI",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/32",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is the result of running `make update-ci` in the repository. I believe this will get the CI working again.",
      "createdAt": "2025-02-26T20:48:54Z",
      "updatedAt": "2025-02-26T21:48:42Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "cc4d029e03f9f75a807ca4db7336c959a98b86e4",
      "headRepository": "davidben/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "fix-ci",
      "headRefOid": "0183a567e6b74cd3846fd93b07a77c053d160dc7",
      "closedAt": "2025-02-26T21:02:05Z",
      "mergedAt": "2025-02-26T21:02:05Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "4dd74c1198cabd487b56018de584ca5646c618e3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOJfxSy86NQcVS",
      "title": "Fix reference to NIST ECC CDH",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/33",
      "state": "MERGED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #29",
      "createdAt": "2025-03-04T07:16:46Z",
      "updatedAt": "2025-03-04T12:27:21Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "df3be576927cfd23b5c089bcd1714d405b94c09e",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/issue_29",
      "headRefOid": "d87f966cad62ada1de8c7d4fc6c4c6f3e7af71d0",
      "closedAt": "2025-03-04T12:27:09Z",
      "mergedAt": "2025-03-04T12:27:09Z",
      "mergedBy": "kriskwiatkowski",
      "mergeCommit": {
        "oid": "5baab051ded4a4561a14533bfd7198fa38deb9b3"
      },
      "comments": [
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "Thnx Bas,",
          "createdAt": "2025-03-04T12:27:20Z",
          "updatedAt": "2025-03-04T12:27:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86eYVMb",
          "commit": {
            "abbreviatedOid": "d87f966"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-04T12:01:31Z",
          "updatedAt": "2025-03-04T12:01:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "PR_kwDOJfxSy86PDnBx",
      "title": "Add text about key reuse",
      "url": "https://github.com/post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem/pull/35",
      "state": "CLOSED",
      "author": "kriskwiatkowski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #34 \r\n\r\n@emanjon how about that?",
      "createdAt": "2025-03-18T08:12:40Z",
      "updatedAt": "2025-03-21T21:42:56Z",
      "baseRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "baseRefName": "main",
      "baseRefOid": "5baab051ded4a4561a14533bfd7198fa38deb9b3",
      "headRepository": "post-quantum-cryptography/draft-kwiatkowski-tls-ecdhe-mlkem",
      "headRefName": "kris/key_reuse",
      "headRefOid": "7513bc4c96e54f60ca5c64c2cf65ce759df2155d",
      "closedAt": "2025-03-21T06:40:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "> Therefore, the client and server must not reuse the ECDH portion of the\r\nkey share across different connections. The client must not reuse the MLKEM portion of the key share. We note that\r\nFIPS-203 conformant implementation of MLKEM doesn't allow key reuse on the server side.\r\n\r\nMust not or MUST NOT?",
          "createdAt": "2025-03-18T08:14:59Z",
          "updatedAt": "2025-03-18T08:14:59Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "@dconnolly Thanks, the latter.",
          "createdAt": "2025-03-18T08:16:19Z",
          "updatedAt": "2025-03-18T08:16:19Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "If the wg likes this language I can use similar in my mlkem-only document ",
          "createdAt": "2025-03-18T08:17:53Z",
          "updatedAt": "2025-03-18T08:17:53Z"
        },
        {
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "body": "The document was adopted by TLS WG and not anymore I-D. That means we need a consensus to get this change in. ",
          "createdAt": "2025-03-21T06:40:59Z",
          "updatedAt": "2025-03-21T06:40:59Z"
        },
        {
          "author": "csosto-pk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to normative language for client and server. With maybe a \"MAY\" for corner cases. ",
          "createdAt": "2025-03-21T21:42:33Z",
          "updatedAt": "2025-03-21T21:42:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJfxSy86gikqx",
          "commit": {
            "abbreviatedOid": "7513bc4"
          },
          "author": "kriskwiatkowski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-18T08:17:28Z",
          "updatedAt": "2025-03-18T08:17:28Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "\"server side\" -> maybe explain that encapsulation doesn't allow key reuse ",
              "createdAt": "2025-03-18T08:17:28Z",
              "updatedAt": "2025-03-18T08:17:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86gjoDM",
          "commit": {
            "abbreviatedOid": "7513bc4"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-18T09:39:45Z",
          "updatedAt": "2025-03-18T09:39:45Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Perhaps we can add \"(For MLKEM this ensures the server's portion is also not reused.)\" after \"The client MUST NOT reuse the MLKEM portion of the key share\" or something to the same affect.",
              "createdAt": "2025-03-18T09:39:45Z",
              "updatedAt": "2025-03-18T09:40:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86gjpcj",
          "commit": {
            "abbreviatedOid": "7513bc4"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-18T09:41:16Z",
          "updatedAt": "2025-03-18T09:41:17Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Although I suppose the server could technically use the same message. Ok, never mind. It's good as is.",
              "createdAt": "2025-03-18T09:41:16Z",
              "updatedAt": "2025-03-18T09:41:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86gjqUM",
          "commit": {
            "abbreviatedOid": "7513bc4"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-18T09:42:19Z",
          "updatedAt": "2025-03-18T09:42:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJfxSy86gmZyF",
          "commit": {
            "abbreviatedOid": "7513bc4"
          },
          "author": "vdukhovni",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-18T12:55:25Z",
          "updatedAt": "2025-03-18T12:59:52Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Is there really a rough consensus to prohibit key reuse, or just one adamant voice?\r\nWhy not document the pros/cons and let implementations decide?\r\nSome clients (server-to-server routine traffic) have no reason to, and get no benefit if they do, avoid session linking.\r\nWhy shouldn't they amortise the cost of key generation via reuse of ML-KEM ephemeral keys?",
              "createdAt": "2025-03-18T12:55:25Z",
              "updatedAt": "2025-03-18T12:59:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJfxSy86gnoOv",
          "commit": {
            "abbreviatedOid": "7513bc4"
          },
          "author": "bwesterb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-18T14:12:23Z",
          "updatedAt": "2025-03-18T14:12:23Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Perhaps you missed it, but support [has been expressed by several people](https://mailarchive.ietf.org/arch/msg/tls/1brhJ5dtxCp1-xYPiKV8tg2uT7k/). You could suggest to the chairs to issue a vote.\r\n\r\n> Why shouldn't they amortise the cost of key generation via reuse of ML-KEM ephemeral keys?\r\n\r\nML-KEM key generation is cheap. It'd have to be a weird setup (offload to HSM?) where the hassle of regenerating keys is worth it.",
              "createdAt": "2025-03-18T14:12:23Z",
              "updatedAt": "2025-03-18T14:12:23Z"
            }
          ]
        }
      ]
    }
  ]
}